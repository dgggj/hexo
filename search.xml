<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>虚拟机篇-1</title>
      <link href="/2022/09/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87-1/"/>
      <url>/2022/09/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87-1/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机篇"><a href="#虚拟机篇" class="headerlink" title="虚拟机篇"></a>虚拟机篇</h1><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a>1. JVM 内存结构</h2><p><strong>要求</strong></p><ul><li>掌握 JVM 内存结构划分</li><li>尤其要知道方法区、永久代、元空间的关系</li></ul><p><strong>结合一段 java 代码的执行理解内存划分</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831165728217.png" alt="image-20210831165728217"></p><ul><li>执行 javac 命令编译源代码为字节码</li><li>执行 java 命令<ol><li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li><li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li><li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li><li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li><li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li><li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li><li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li><li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li><li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li><li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li></ol></li></ul><p>说明</p><ul><li>加粗字体代表了 JVM 虚拟机组件</li><li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li></ul><p><strong>会发生内存溢出的区域</strong></p><ul><li>不会出现内存溢出的区域 – 程序计数器</li><li>出现 OutOfMemoryError 的情况<ul><li>堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收</li><li>方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li>虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时</li></ul></li><li>出现 StackOverflowError 的区域<ul><li>JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用</li></ul></li></ul><p><strong>方法区、永久代、元空间</strong></p><ul><li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li><li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li><li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831170457337.png" alt="image-20210831170457337"></p><p>从这张图学到三点</p><ul><li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li><li>X，Y 的类元信息是存储于元空间中，无法直接访问</li><li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831170512418.png" alt="image-20210831170512418"></p><p>从这张图可以学到</p><ul><li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li><li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li></ul><h2 id="2-JVM-内存参数"><a href="#2-JVM-内存参数" class="headerlink" title="2. JVM 内存参数"></a>2. JVM 内存参数</h2><p><strong>要求</strong> </p><ul><li>熟悉常见的 JVM 参数，尤其和大小相关的</li></ul><p><strong>堆内存，按大小设置</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831173130717.png" alt="image-20210831173130717"></p><p>解释：</p><ul><li>-Xms 最小堆内存（包括新生代和老年代）</li><li>-Xmx 最大对内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li>-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li><li>-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等</li><li>保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同</li></ul><p><strong>堆内存，按比例设置</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831173045700.png" alt="image-20210831173045700"></p><p>解释：</p><ul><li>-XX:NewRatio&#x3D;2:1 表示老年代占两份，新生代占一份</li><li>-XX:SurvivorRatio&#x3D;4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份</li></ul><p><strong>元空间内存设置</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831173118634.png" alt="image-20210831173118634"></p><p>解释：</p><ul><li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li><li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li><li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li></ul><p>注意：</p><ul><li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li></ul><p><strong>代码缓存内存设置</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831173148816.png" alt="image-20210831173148816"></p><p>解释：</p><ul><li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li><li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul><li>non-nmethods - JVM 自己用的代码</li><li>profiled nmethods - 部分优化的机器码</li><li>non-profiled nmethods - 完全优化的机器码</li></ul></li></ul><p><strong>线程内存设置</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831173155481.png" alt="image-20210831173155481"></p><blockquote><p><em><strong>官方参考文档</strong></em></p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></li></ul></blockquote><h2 id="3-JVM-垃圾回收"><a href="#3-JVM-垃圾回收" class="headerlink" title="3. JVM 垃圾回收"></a>3. JVM 垃圾回收</h2><p><strong>要求</strong></p><ul><li>掌握垃圾回收算法</li><li>掌握分代回收思想</li><li>理解三色标记及漏标处理</li><li>了解常见垃圾回收器</li></ul><p><strong>三种垃圾回收算法</strong></p><p>标记清除法</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831211008162.png" alt="image-20210831211008162"></p><p>解释：</p><ol><li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li><li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li><li>清除阶段：释放未加标记的对象占用的内存</li></ol><p>要点：</p><ul><li>标记速度与存活对象线性关系</li><li>清除速度与内存大小线性关系</li><li>缺点是会产生内存碎片</li></ul><p>标记整理法</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831211641241.png" alt="image-20210831211641241"></p><p>解释：</p><ol><li>前面的标记阶段、清理阶段与标记清除法类似</li><li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li></ol><p>特点：</p><ul><li><p>标记速度与存活对象线性关系</p></li><li><p>清除与整理速度与内存大小成线性关系</p></li><li><p>缺点是性能上较慢</p></li></ul><p>标记复制法</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831212125813.png" alt="image-20210831212125813"></p><p>解释：</p><ol><li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li><li>标记阶段与前面的算法类似</li><li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li><li>复制完成后，交换 from 和 to 的位置即可</li></ol><p>特点：</p><ul><li>标记与复制速度与存活对象成线性关系</li><li>缺点是会占用成倍的空间</li></ul><p><strong>GC 与分代回收算法</strong></p><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p><p>GC 要点：</p><ul><li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li><li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC 具体的实现称为<strong>垃圾回收器</strong></li><li>GC 大都采用了<strong>分代回收思想</strong><ul><li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li></ul></li><li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li></ul><p><strong>分代回收</strong></p><ol><li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213622704.png" alt="image-20210831213622704"></p><ol start="2"><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213640110.png" alt="image-20210831213640110"></p><ol start="3"><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213657861.png" alt="image-20210831213657861"></p><ol start="4"><li>将 from 和 to 交换位置</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213708776.png" alt="image-20210831213708776"></p><ol start="5"><li>经过一段时间后伊甸园的内存又出现不足</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213724858.png" alt="image-20210831213724858"></p><ol start="6"><li>标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213737669.png" alt="image-20210831213737669"></p><ol start="7"><li>将存活对象采用复制算法复制到 to 中</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213804315.png" alt="image-20210831213804315"></p><ol start="8"><li>复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213815371.png" alt="image-20210831213815371"></p><ol start="9"><li>将 from 和 to 交换位置</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831213826017.png" alt="image-20210831213826017"></p><ol start="10"><li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ol><p><strong>GC 规模</strong></p><ul><li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></li></ul><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li>起始的三个对象还未处理完成，用灰色表示</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" /><ol start="2"><li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" /><ol start="3"><li>依次类推</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" /><ol start="4"><li>沿着引用链都标记了一遍</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" /><ol start="5"><li>最后为标记的白色对象，即为垃圾</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" /><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li>如图所示标记工作尚未完成</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" /><ol start="2"><li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" /><ol start="3"><li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" /><ol start="4"><li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" /><p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul><li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li></ul></li><li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul><li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li><li>新加对象会被记录</li><li>被删除引用关系的对象也被记录</li></ul></li></ol><p><strong>垃圾回收器 - Parallel GC</strong></p><ul><li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p></li><li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p></li><li><p><strong>注重吞吐量</strong></p></li></ul><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p><ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li><li><p><strong>注重响应时间</strong></p></li></ul><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>G1 回收阶段 - 新生代回收</strong></p><ol><li>初始时，所有区域都处于空闲状态</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222639754.png" alt="image-20210831222639754" style="zoom:50%;" /><ol start="2"><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222653802.png" alt="image-20210831222653802" style="zoom:50%;" /><ol start="3"><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222705814.png" alt="image-20210831222705814" style="zoom:50%;" /><ol start="4"><li>复制完成，将之前的伊甸园内存释放</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222724999.png" alt="image-20210831222724999" style="zoom:50%;" /><ol start="5"><li>随着时间流逝，伊甸园的内存又有不足</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222737928.png" alt="image-20210831222737928" style="zoom:50%;" /><ol start="6"><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222752787.png" alt="image-20210831222752787" style="zoom:50%;" /><ol start="7"><li>释放伊甸园以及之前幸存区的内存</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222803281.png" alt="image-20210831222803281" style="zoom:50%;" /><p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p><ol><li>当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222813959.png" alt="image-20210831222813959" style="zoom:50%;" /><ol start="2"><li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222828104.png" alt="image-20210831222828104" style="zoom:50%;" /><ol start="3"><li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222841096.png" alt="image-20210831222841096" style="zoom:50%;" /><ol start="4"><li>下图显示了老年代和幸存区晋升的存活对象的复制</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222859760.png" alt="image-20210831222859760" style="zoom:50%;" /><ol start="5"><li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210831222919182.png" alt="image-20210831222919182" style="zoom:50%;" /><h2 id="4-内存溢出"><a href="#4-内存溢出" class="headerlink" title="4. 内存溢出"></a>4. 内存溢出</h2><p><strong>要求</strong></p><ul><li>能够说出几种典型的导致内存溢出的情况</li></ul><p><strong>典型情况</strong></p><ul><li>误用线程池导致的内存溢出<ul><li>参考 day03.TestOomThreadPool</li></ul></li><li>查询数据量太大导致的内存溢出<ul><li>参考 day03.TestOomTooManyObject</li></ul></li><li>动态生成类导致的内存溢出<ul><li>参考 day03.TestOomTooManyClass</li></ul></li></ul><h2 id="5-类加载"><a href="#5-类加载" class="headerlink" title="5. 类加载"></a>5. 类加载</h2><p><strong>要求</strong></p><ul><li>掌握类加载阶段</li><li>掌握类加载器</li><li>理解双亲委派机制</li></ul><p><strong>类加载过程的三个阶段</strong></p><ol><li><p>加载</p><ol><li><p>将类的字节码载入方法区，并创建类.class 对象</p></li><li><p>如果此类的父类没有加载，先加载父类</p></li><li><p>加载是懒惰执行</p></li></ol></li><li><p>链接</p><ol><li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li><li>准备 – 为 static 变量分配空间，设置默认值</li><li>解析 – 将常量池的符号引用解析为直接引用</li></ol></li><li><p>初始化</p><ol><li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li><li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li><li>初始化是懒惰执行</li></ol></li></ol><blockquote><p><em><strong>验证手段</strong></em></p><ul><li>使用 jps 查看进程号</li><li>使用 jhsdb 调试，执行命令 <code>jhsdb.exe hsdb</code> 打开它的图形界面<ul><li>Class Browser 可以查看当前 jvm 中加载了哪些类</li><li>控制台的 universe 命令查看堆内存范围</li><li>控制台的 g1regiondetails 命令查看 region 详情</li><li><code>scanoops 起始地址 结束地址 对象类型</code> 可以根据类型查找某个区间内的对象地址</li><li>控制台的 <code>inspect 地址</code> 指令能够查看这个地址对应的对象详情</li></ul></li><li>使用 javap 命令可以查看 class 字节码</li></ul></blockquote><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载</li><li>day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载</li></ul></blockquote><p><strong>jdk 8 的类加载器</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>加载哪的类</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为 Bootstrap，显示为  null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><p><strong>双亲委派机制</strong></p><p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p><ul><li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li><li>找不到这个类，则下级类加载器才有资格执行加载</li></ul><p>双亲委派的目的有两点</p><ol><li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p></li><li><p>让类的加载有优先次序，保证核心类优先加载</p></li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系</li></ul></blockquote><h2 id="7-finalize"><a href="#7-finalize" class="headerlink" title="7. finalize"></a>7. finalize</h2><p><strong>要求</strong></p><ul><li>掌握 finalize 的工作原理与缺点</li></ul><p><strong>finalize</strong></p><ul><li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li><li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li></ul><p><strong>finalize 原理</strong></p><ol><li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li><li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210901121032813.png" alt="image-20210901121032813"></p><ol start="3"><li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li><li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li><li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/image-20210901122228916.png" alt="image-20210901122228916"></p><ol start="6"><li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li></ol><p><strong>finalize 缺点</strong></p><ul><li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了</li><li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li><li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li><li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestFinalize - finalize 的测试代码</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day2用友</title>
      <link href="/2022/09/13/day2%E7%94%A8%E5%8F%8B/"/>
      <url>/2022/09/13/day2%E7%94%A8%E5%8F%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1死锁"><a href="#1死锁" class="headerlink" title="1死锁"></a>1死锁</h4><ul><li>不同的线程分别占用对方需要的资源不放弃，都在等待对方放弃自己需要的同步资源形成线程的死锁</li><li>死锁后，不会出现异常，不会出现提示，所有的线程都处于阻塞状态，无法继续</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    StringBuffer s1=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    StringBuffer s2=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(s1)&#123;</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(s2)&#123;</span><br><span class="line">          s1.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">          s2.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(s2)&#123;</span><br><span class="line">        s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(s1)&#123;</span><br><span class="line">          s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">          s2.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解决方法<ul><li>尽可能减少嵌套</li><li>减少同步资源的定义</li></ul></li></ul><h4 id="2线程状态"><a href="#2线程状态" class="headerlink" title="2线程状态"></a>2线程状态</h4><p><a href="https://huyulong.cn/2022/07/12/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%88java%EF%BC%89/">六种线程状态</a></p><h4 id="3Linux"><a href="#3Linux" class="headerlink" title="3Linux"></a>3Linux</h4><p><a href="https://huyulong.cn/2022/04/05/linux%E5%91%BD%E4%BB%A4/">Linux</a></p><h4 id="4select、poll、epoll"><a href="#4select、poll、epoll" class="headerlink" title="4select、poll、epoll"></a>4select、poll、epoll</h4><p>IO多路复用</p><h4 id="5TCP三次握手、四次挥手"><a href="#5TCP三次握手、四次挥手" class="headerlink" title="5TCP三次握手、四次挥手"></a>5TCP三次握手、四次挥手</h4><p><a href="https://huyulong.cn/2022/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C-%E6%80%BB%E7%BB%93/">三次握手、四次挥手</a></p><h4 id="6TCP可靠传输"><a href="#6TCP可靠传输" class="headerlink" title="6TCP可靠传输"></a>6TCP可靠传输</h4><ul><li>校验和：<ul><li>发送方：在发送数据之前计算校验和，并进行校验和的填充</li><li>接收方：在收到数据后，对数据以同样的方式进行计算，求出 校验和，与发送方的进行比对</li></ul></li><li>序列号和确认应答:tcp传输时将每个字节的数据都进行了编号，就是序列号，Ack报文中就带有对应的确认序列号，告诉发送方，接到哪些数据，下一次的数据应该从哪里发。序列号作用：1.应答2.将接收到的数据按照序列号排序，3去掉序列号重复的数据</li><li>超时重传：解决发送方发送完数据，没有接收到ACK报文的问题。就是等待一段时间，如果没有收到Ack报文，就重新发送</li><li>连接管理：三次握手四次挥手</li><li>流量控制：Tcp可以根据接受端对数据处理能力，决定发送端的发送速度，这个机制就是流量控制</li><li>拥塞控制：引入慢启动机制，在开始发送数据时，先发送少量的数据探路，探清当前的网络状态如何，再决定多大的速度进行传输。引入拥塞窗口，刚开始为1；呈指数增长。设置一个拥塞窗口的阈值，当达到阈值，增长按照线性增长。当网络拥塞时，设置拥塞阈值为网络拥塞时的一半，并且把拥塞窗口设置为1.</li></ul><p>校验和的计算方式：在数据传输的过程中，将发送的数据段当作一个16位整数，把这些整数加起来，进位再和得到的数相加，最后取反，得到校验和。</p><p><img src="/Users/xiaoluyouqu/%E9%9D%A2%E8%AF%95/%E5%9B%BE%E7%89%87/tcp.png" alt="tcp"></p><h4 id="10二叉树的遍历方式"><a href="#10二叉树的遍历方式" class="headerlink" title="10二叉树的遍历方式"></a>10二叉树的遍历方式</h4><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层次遍历</li></ul><h4 id="11平衡二叉树"><a href="#11平衡二叉树" class="headerlink" title="11平衡二叉树"></a>11平衡二叉树</h4><p>对于<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&spm=1001.2101.3001.7020">二叉查找树</a>，尽管查找、插入及删除操作的平均运行时间为O(logn)，但是它们的最差运行时间都是O(n),原因在于对树的形状没有限制。</p><p><a href="https://so.csdn.net/so/search?q=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">平衡二叉树</a>又称为AVL树，它或者是一棵空树，或者是有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左右子树的深度之差的绝对值不超过1。二叉树的的平衡因子BF为：该结点的左子树的深度减去它的右子树的深度，则平衡二叉树的所有结点的平衡因子为只可能是：-1、0和1</p><p>一棵好的平衡二叉树的特征：</p><p>（1）保证有n个结点的树的高度为O(logn)</p><p>（2）容易维护，也就是说，在做数据项的插入或删除操作时，为平衡树所做的一些辅助操作时间开销为O(1)</p><p>一、平衡二叉树的构造</p><p>在一棵二叉查找树中插入结点后，调整其为平衡二叉树。若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性。首先要找出插入新结点后失去平衡的最小子树根结点的指针。然后再调整这个子树中有关结点之间的链接关系，使之成为新的平衡子树。当失去平衡的最小子树被调整为平衡子树后，原有其他所有不平衡子树无需调整，整个二叉排序树就又成为一棵平衡二叉树</p><p>1.调整方法</p><p>（1）插入点位置必须满足二叉查找树的性质，即任意一棵子树的左结点都小于根结点，右结点大于根结点</p><p>（2）找出插入结点后****不平衡的最小二叉树****进行调整，如果是整个树不平衡，才进行整个树的调整。</p><h4 id="12JVM类加载过程"><a href="#12JVM类加载过程" class="headerlink" title="12JVM类加载过程"></a>12JVM类加载过程</h4><p><a href="https://huyulong.cn/2022/04/07/JVM-02%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/">类加载过程</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试1</title>
      <link href="/2022/09/08/%E9%9D%A2%E8%AF%951/"/>
      <url>/2022/09/08/%E9%9D%A2%E8%AF%951/</url>
      
        <content type="html"><![CDATA[<h4 id="1-数据库和缓存一致性"><a href="#1-数据库和缓存一致性" class="headerlink" title="1.数据库和缓存一致性"></a>1.数据库和缓存一致性</h4><p>1.命中：程序从缓存中读取数据，如果命中，则直接返回</p><p>2.失效：程序从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中</p><p>3.更新：程序先更新更新数据库，再删除缓存。</p><p>更新：</p><p>1.先更新缓存，再更新数据库。</p><p>如果先更新缓存，但更新数据库的时候失败了，这个时候需要回滚，也要把Redis缓存的回滚了，但Redis的缓存有可能是做过很多计算才得到缓存在里面，如果回滚，那就白算了。</p><p>2.先更新数据库，再更新缓存。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/huancun.png" alt="huancun"></p><p>如上图所示，如果线程A更新完数据库，CPU的资源被线程2获得，并执行更新数据库和缓存，线程1再获取cpu资源时更新了缓存，最终会出现数据库为2缓存是1的状况。此时缓存中的1是脏数据。</p><p>（3）先删除缓存，再更新数据库</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/huancun2.png" alt="huancun"></p><p>线程A先删除缓存后，Cpu资源就被线程B获得，线程B在缓存中找不到数据，就去数据库中读取旧值，线程A又获取cpu，把A&#x3D;2更新到数据库中。线程B再获取cpu资源，他要把A&#x3D;1写到缓存中。此时数据库为2，缓存为1</p><p>（4）先更新数据库，再删除缓存</p><p>也会出现一些问题，但机率有点小,因为读的速度一般会比更新速度快。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/huancun3.png" alt="3"></p><p>可以过几秒再删除一次，延迟双删。</p><p>Mysql读写分离（主从架构）</p><p>可能出现的问题：</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/cun5.png" alt="mysql"></p><p>增加一个订阅binlogin系统，订阅主数据库的binlog，那么这个服务系统内的数据一定是最新的，而且还是有序的。用这个系统更新redis就不会有。万一更新失败，又创建一个消息队列，把更新的数据丢到消息队列中。消息队列失败是可以重新发送的。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/mianshi/cun4.png" alt="5" style="zoom:67%;" /><h4 id="2抽象类和接口的异同"><a href="#2抽象类和接口的异同" class="headerlink" title="2抽象类和接口的异同"></a>2抽象类和接口的异同</h4><ul><li>抽象类和接口都是为了将方法进行抽象，然后让子类去实现。所以可以定义抽象方法就是它们两者第一个相同点。这些父类是没有必要创建实例对象的，所以他们不创建本类对象，只能由子类去实例化子类对象。</li><li>子类想要拓展它们时，对抽象类使用的是extends关键词-继承，对接口使用implements关键词-实现，一个类最多只能继承一个父类，可以实现多个接口。这样如果发现既可以使用抽象类，也可以使用接口时，尽量使用接口，子类的灵活度会更高。</li><li>接口比抽象类更纯粹因为它没有成员属性，只有方法子类实现接口后只能做重写方法，子类继承抽象类后，还将抽象类的成员属性也继承了。抽象类可以定义成员属性，接口不能定义成员属性。只能定义静态属性，而且只能用final修饰定义静态常量。接口中也没有构造器。总的来说接口是只有方法和静态常量的类</li><li>抽象类可以定义构造方法，这是为了限制子类，如果子类继承就必须传入这些参数。</li></ul><p>java1.8之后。接口可以构造静态方法和default方法。因为java1.8添加很多方法，那么它的子类就必须全都要实现这些方法。定义为default方法之后它就不是抽象方法，因此不需要去实现</p><p>总结：</p><p>接口就是更加纯粹的抽象类，接口中只能是静态常量和抽象方法。java1.8添加（default方法和静态方法），java9出现private方法。接口不能继承类，但可以继承多个接口。抽象类中可以由构造器、抽象方法、普通成员方法、成员变量、静态方法、静态变量、常量。</p><p>如果你需要让子类继承父类的成员变量或者需要控制子类的实例化时使用抽象类。</p><h4 id="3-final关键词"><a href="#3-final关键词" class="headerlink" title="3 final关键词"></a>3 final关键词</h4><ul><li>final用在类上表示这个类不能被继承</li><li>final修饰方法表示这个方法不能被子类重写</li><li>final修饰变量则该变量被赋值后不能被修改，无论成员变量、局部变量都一样</li><li>如果修饰引用类型，则代表这个引用只有一次指向对象的机会，但对象的成员属性可以修改。</li></ul><p>、</p><h4 id="4-static关键词"><a href="#4-static关键词" class="headerlink" title="4 static关键词"></a>4 static关键词</h4><p>static的作用：1.静态属性。2.静态方法。3静态代码块。4静态导包</p><p>定义属性和方法时，加上static关键词变成静态属性和静态代码块。不用创建对象，直接通过类名便可以调用这个属性和方法，不需要创建。静态属性和方法属于类，成员属性和类属于对象。</p><p>静态代码块在类初始化时会运行一次。普通代码块在每个对象创建时运行一次。</p><p>顺序：</p><p>父类：静态属性&#x2F;静态代码块–&gt;子类：静态属性&#x2F;静态代码块–&gt;</p><p>父类：成员属性&#x2F;成员代码块–&gt;父类：构造器</p><p>子类：成员属性&#x2F;成员代码块–&gt;子类：构造器</p><h4 id="5-Iterator迭代器"><a href="#5-Iterator迭代器" class="headerlink" title="5 Iterator迭代器"></a>5 Iterator迭代器</h4><ul><li><p>Fail-fast 一旦发现遍历的同时其他人来修改，则立即抛出异常。list会记录修改次数modCount；进入遍历时Iterator迭代器会记录它改变的次数expectedModCount，迭代的时候会用modCounth和expectedModCount比较，不同就会抛出异常。</p></li><li><p>Fail-Safe 发现遍历的同时其他人来修改，应当有对应的策略，例如牺牲一致性来让整个遍历运行完成。 它调用的时COWInterator迭代器，它迭代时会把要迭代的数据也由snapshot数组指向。但copyOnWritelist方法的add是复制一个新的数组，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">es=Arrays。copyOf(es,len+<span class="number">1</span>);es[len]=e;所以迭代器迭代的数组和修改数据的数组不是同一个.</span><br></pre></td></tr></table></figure></li></ul><p> Fail-Fast 与 Fail-Safe</p><ul><li>ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败</li><li>CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离</li></ul><h4 id="6-HashMap"><a href="#6-HashMap" class="headerlink" title="6 HashMap"></a>6 HashMap</h4><ul><li><p>1.7是数组加链表    - 1.8数组+（链表｜红黑树）</p></li><li><p>数组扩容是链表长度大于8或者元素个数超过容量大0.75时会扩容</p></li><li><p>当链表的长度大于8或者数组容量大于64时，会树化变成红黑树。红黑树一般来说是为了防止Dos攻击导致链表过长，性能下降。红黑树的查询速度是log2n，但由于红黑树是TreeNode节点占用空间比Node节点，所以如非必要还是用链表。</p></li><li><p>1.当扩容时如果拆分树了，且树元素个数&lt;&#x3D;6会退化链表。2.remove树节点时，当root节点、root.left,root.right,root.left.left有一个为null时，也会退化成链表</p></li><li><p>索引计算，首先计算对象的hashcode（），再调用hashmap的hash（）方法进行二次哈希。二次hash是为了分布更均匀最后与（capacity-1）进行与运算得到索引</p></li><li><p>put流程：</p><ul><li>1.HashMap是懒惰创建数组的，首次使用才创建数组。</li><li>2.计算索引（桶下标）</li><li>3.如果桶下表还没人占用，则创建Node返回</li><li>4如果桶下标已经被占用：<ul><li>是TreeNode走红黑树的添加或者更新逻辑</li><li>是普通的Node走链表的添加更新逻辑，如果链表长度超过树化值，走树化逻辑</li></ul></li><li>返回前检查容量是否超过阀值，一旦超过就扩容</li></ul></li><li><p>HashMap的key可以为null，其他不行</p></li></ul><h4 id="7线程池的7大核心参数"><a href="#7线程池的7大核心参数" class="headerlink" title="7线程池的7大核心参数"></a>7线程池的7大核心参数</h4><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><p><img src="/Users/xiaoluyouqu/%E9%9D%A2%E8%AF%95/%E5%9B%BE%E7%89%87/6.png" alt="tu"></p><h4 id="8-wait-vs-sleep"><a href="#8-wait-vs-sleep" class="headerlink" title="8 wait vs sleep"></a>8 wait vs sleep</h4><p><strong>一个共同点，三个不同点</strong></p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li>方法归属不同<ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li>锁特性不同（重点）<ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型-JMM</title>
      <link href="/2022/08/03/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/"/>
      <url>/2022/08/03/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/</url>
      
        <content type="html"><![CDATA[<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="1-什么是JMM"><a href="#1-什么是JMM" class="headerlink" title="1.什么是JMM?"></a>1.什么是JMM?</h3><p>JMM(java内存模型)是一种符合计算机内存模型规范的，屏蔽了各种硬件和操作系统的访问内存差异的，保证java程序在各种平台下对内存的访问都能得到一致性效果的一种机制以及规范。目的是解决多线程通过内存共享进行通讯时存在的一些原子性、有序性、可见性的问题</p><p>每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷回到主存。这是 Java 内存模型定义的线程基本工作方式。<img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/jmm/1.png" alt="1"></p><p>整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：原子性，可见性，有序性。这三个特征可谓是整个Java并发的基础。</p><h3 id="2-三大特性"><a href="#2-三大特性" class="headerlink" title="2.三大特性"></a>2.三大特性</h3><h4 id="2-1原子性"><a href="#2-1原子性" class="headerlink" title="2.1原子性"></a>2.1原子性</h4><p>原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰</p><p>如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">2</span>;  <span class="comment">//原子性</span></span><br><span class="line"><span class="type">int</span> j=i;  <span class="comment">//先读取i的值，再赋值到j，两步操作，不能保证原子性</span></span><br><span class="line">i++;  <span class="comment">//不能保证原子性</span></span><br><span class="line">i=i+<span class="number">1</span>;  <span class="comment">//不能保证原子性</span></span><br></pre></td></tr></table></figure><p>JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p><h4 id="2-2-可见性"><a href="#2-2-可见性" class="headerlink" title="2.2 可见性"></a>2.2 可见性</h4><p>可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改。</p><p>Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。</p><p>除了volatile关键字之外，final和synchronized也能实现可见性。</p><p>synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。</p><p>final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。</p><h4 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h4><p>在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别：</p><p>volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。</p><p>synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。</p><h3 id="3-八种内存交互操作"><a href="#3-八种内存交互操作" class="headerlink" title="3 八种内存交互操作"></a>3 八种内存交互操作</h3><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/jmm/2.png" alt="2"></p><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>补充：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul><h3 id="4-volatile关键词"><a href="#4-volatile关键词" class="headerlink" title="4 volatile关键词"></a>4 volatile关键词</h3><ol><li><strong>保证线程间变量的可见性。</strong></li><li>禁止CPU进行指令重排序。</li></ol><ul><li>可见性</li></ul><p>volatile修饰的变量，当一个线程改变了该变量的值，其他线程是立即可见的。普通变量则需要重新读取才能获得最新值。</p><p>保证可见性的流程为：</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/jmm/3.png" alt="3"></p><p>volatile不能保证线程安全,可见性不能保证操作的原子性</p><ul><li>禁止指令重排序</li></ul><p>首先要讲一下as-if-serial语义，不管怎么重排序，（单线程）程序的执行结果不能被改变。</p><p>为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做<strong>指令的重排序</strong>。</p><p>重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序。整个过程如下所示：</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/jmm/4.png" alt="4"></p><p>指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但是在多线程的环境下就不能保证一定不会影响执行结果了。</p><p><strong>所以在多线程环境下，就需要禁止指令重排序</strong>。</p><p>volatile关键字禁止指令重排序有两层意思：</p><ul><li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。</li><li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li></ul><p>volatile禁止指令重排序的原理是什么</p><p>首先要讲一下内存屏障，内存屏障可以分为以下几类：</p><ul><li>LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul><p>在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式</title>
      <link href="/2022/07/27/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/27/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><h3 id="1学习设计模式的意义"><a href="#1学习设计模式的意义" class="headerlink" title="1学习设计模式的意义"></a>1学习设计模式的意义</h3><h4 id="1-1什么是设计模式"><a href="#1-1什么是设计模式" class="headerlink" title="1.1什么是设计模式"></a>1.1什么是设计模式</h4><ul><li>设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。他不是语法规定，而是一套用来提高代码可重复性、可维护性、可读性、稳健性以及安全性的解决方案</li></ul><h4 id="1-2设计模式的本质"><a href="#1-2设计模式的本质" class="headerlink" title="1.2设计模式的本质"></a>1.2设计模式的本质</h4><p>设计模式本质是面向对象设计原则的实际应用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解</p><h4 id="1-3设计模式的优点"><a href="#1-3设计模式的优点" class="headerlink" title="1.3设计模式的优点"></a>1.3设计模式的优点</h4><ul><li>可以提高程序员的思维能力、编程能力和设计能力</li><li>使程序设计更加标准化、代码编制更加工程化，使软件的开发效率大大提高，从而缩短软件的开发周期</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li></ul><p>设计模式的基本要素</p><ul><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果</li></ul><h4 id="1-4-23种设计模式"><a href="#1-4-23种设计模式" class="headerlink" title="1.4 23种设计模式"></a>1.4 23种设计模式</h4><ul><li>创建型模式：主要为了对象的创建和使用分离<ul><li>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式</li></ul></li><li>结构型模式：主要为了把我们的类或者对象按照某种方式组成一个更大的结构<ul><li>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</li></ul></li><li>行为模式：描述类或者对象之间如何相互协作完成单个对象无法完成的事<ul><li>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式</li></ul></li></ul><h4 id="1-7-面向对象（OOP）的七大原则"><a href="#1-7-面向对象（OOP）的七大原则" class="headerlink" title="1.7 面向对象（OOP）的七大原则"></a>1.7 面向对象（OOP）的七大原则</h4><ul><li>开闭原则：对拓展开放，对修改关闭。意思为如果需要增加新功能不要改原先代码，而是拓展出来</li><li>里氏替换原则：继承必须确保父类所拥有的性质在子类依然成立。意思为父类的功能在子类仍然成立，子类只继承父类的功能，最好不要修改父类的功能，只做拓展新功能</li><li>依赖倒置原则：要面向接口编程，不要面向实现编程</li><li>单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性。</li><li>接口隔离原则：要为各个类创建它们需要的专用接口</li><li>迪米特法则：只跟你的直接朋友交谈，不和“陌生人”说话</li><li>合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系实现</li></ul><h3 id="2单例模式"><a href="#2单例模式" class="headerlink" title="2单例模式"></a>2单例模式</h3><h4 id="2-1饿汉式"><a href="#2-1饿汉式" class="headerlink" title="2.1饿汉式"></a>2.1饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"><span class="comment">//饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Hungry hungry=<span class="keyword">new</span> <span class="title class_">Hungry</span>();<span class="comment">//直接new一个实例</span></span><br><span class="line">    <span class="comment">//抛出一个对外的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一上来就创建对象，会浪费内存资源。比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"><span class="comment">//饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line">    <span class="comment">//可能会浪费空间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data1=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data2=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data3=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data4=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Hungry hungry=<span class="keyword">new</span> <span class="title class_">Hungry</span>();<span class="comment">//直接new一个实例</span></span><br><span class="line">    <span class="comment">//抛出一个对外的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要用的时候再创建对象，平时的时候就放在一边。</p><h4 id="2-2懒汉式单例"><a href="#2-2懒汉式单例" class="headerlink" title="2.2懒汉式单例"></a>2.2懒汉式单例</h4><p>只有在用的时候创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            lazyMan=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在单线程下是没有问题的，但在多线程并发下，会出问题；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">            lazyMan=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多线程并发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                LazyMan.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可以看到有时创建不止一个对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-1</span><br><span class="line">Thread-3;</span><br><span class="line">Thread-0;</span><br><span class="line">Thread-2</span><br></pre></td></tr></table></figure><p>所以需要给它加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan=<span class="literal">null</span>;<span class="comment">//所重检测锁模式的 懒汉式单例 DCL懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">               <span class="keyword">if</span> (lazyMan==<span class="literal">null</span>)&#123;</span><br><span class="line">                   lazyMan=<span class="keyword">new</span> <span class="title class_">LazyMan</span>();<span class="comment">//不是原子性操作</span></span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                   *1分配内存空间</span></span><br><span class="line"><span class="comment">                   *2执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                   *3把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                   </span></span><br><span class="line"><span class="comment">                   123</span></span><br><span class="line"><span class="comment">                   132</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> lazyMan;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>volatile保证顺序性</p><h4 id="2-3静态内部类"><a href="#2-3静态内部类" class="headerlink" title="2.3静态内部类"></a>2.3静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.holder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Holder holder=<span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种都不太安全。</p><h4 id="2-4-懒汉模式被破坏"><a href="#2-4-懒汉模式被破坏" class="headerlink" title="2.4 懒汉模式被破坏"></a>2.4 懒汉模式被破坏</h4><p>就算是懒汉式模式也可以用反射破坏单例模式；</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     LazyMan instance=LazyMan.getInstance();</span><br><span class="line">     Constructor&lt;LazyMan&gt; declaredConstructor =     LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);<span class="comment">//获得类的空参构造器</span></span><br><span class="line">     declaredConstructor.setAccessible(<span class="literal">true</span>);<span class="comment">//访问私有的构造器</span></span><br><span class="line">     LazyMan instance2=declaredConstructor.newInstance();<span class="comment">//利用反射去构建对象</span></span><br><span class="line">     System.out.println(instance2);</span><br><span class="line">     System.out.println(instance);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种情况下输出的地址不同，说明是两个不同的对象</p><p>可以解决这种情况。在构造器中再加把锁，当lazyMan不等于null说明已经创建了。有人在用反射破坏单例模式，则给它抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyMan!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要搞破坏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还是会出问题，这是因为先创建LazyMan instance&#x3D;LazyMan.getInstance();再使用反射时，lanMan不为空，如果不用正常方法创建对象。直接两次用反射构建对象。还是出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        LazyMan instance=LazyMan.getInstance();</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        LazyMan instance2=declaredConstructor.newInstance();</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这俩个对象还是不同的，且没有抛出异常</p><p>解决方法：设置一个加密后的变量设置为flase；当经过构造函数时把他设置为true;</p><p>如果经过构造函数时不为flase;则抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> che=<span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">           <span class="keyword">if</span>(che==<span class="literal">false</span>)&#123;</span><br><span class="line">               che=<span class="literal">true</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要搞破坏&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当然这种也是可以破解的，可以反编译找到这个变量。然后获取这个字段，然后访问这个字段，并把它设置为flase；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="type">Field</span> <span class="variable">che</span> <span class="operator">=</span> LazyMan.class.getDeclaredField(<span class="string">&quot;che&quot;</span>);</span><br><span class="line">     che.setAccessible(<span class="literal">true</span>);</span><br><span class="line">     Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor();</span><br><span class="line">     declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">     LazyMan instance2=declaredConstructor.newInstance();</span><br><span class="line">     che.set(instance2,<span class="literal">false</span>);</span><br><span class="line">     <span class="type">LazyMan</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">     System.out.println(instance2);</span><br><span class="line">     System.out.println(instance);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-5枚举单例"><a href="#2-5枚举单例" class="headerlink" title="2.5枚举单例"></a>2.5枚举单例</h4><p>反射不能破化枚举单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//enum 是一个什么？本身也是一个Class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//经源码找到它没有无参构造，而是这两个参数的有参构造</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">enumSingle</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(enumSingle);</span><br><span class="line">        System.out.println(instance);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">        SINGLETON;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">SingletonEnum</span><span class="params">()</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点</li><li>常见场景：<ul><li>Windows的任务管理器</li><li>Windows的回收站</li><li>项目中，读取配置文件的类，一般也只有一个对象，没必要每次都去new对象读取</li><li>网站的计数器一般也采用单例模式，保证同步</li><li>数据库的连接池的设计一般也是单例模式</li><li>在Servlet编程中，每个Servlet也是单例的</li><li>在Spring中，每个Bean默认就是单例的</li><li>。。。。</li></ul></li></ul><h3 id="3工厂模式"><a href="#3工厂模式" class="headerlink" title="3工厂模式"></a>3工厂模式</h3><p>作用：</p><ul><li>实现创建者和调用者的分离</li><li>详细分类：<ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul></li></ul><p>OOP原则：</p><ul><li>开闭原则：对拓展开放，对修改关闭。意思为如果需要增加新功能不要改原先代码，而是拓展出来</li><li>依赖倒置原则：要面向接口编程，不要面向实现编程</li><li>迪米特法则：只跟你的直接朋友交谈，不和“陌生人”说话</li></ul><p>核心本质：</p><ul><li>实例化对象不使用new，用工厂方法代替</li><li>将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的现实类解耦</li></ul><h4 id="3-1简单工厂模式"><a href="#3-1简单工厂模式" class="headerlink" title="3.1简单工厂模式"></a>3.1简单工厂模式</h4><p>比如创建一个Car接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再创建wuling和Tesla类继承Car这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wuling</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car is wuling&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tesla</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tesla&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照传统的方法需要把它们new出来，然后调用name接口，简单工厂模式是创建一个工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String car)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(car.equals(<span class="string">&quot;wuling&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wuling</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (car.equals(<span class="string">&quot;tesla&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tesla</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，消费者只需要调用工厂类携带参数就可以创建想要的车类了如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;wuling&quot;</span>);</span><br><span class="line">        car.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要new对象出来再调用。</p><p>但这样还是会出问题。比如再创建一个Dazhong车类继承Car接口。那么就需要修改工厂代码。这就不符合扩展开，修改闭原则</p><p>静态工厂模式，</p><p>新增一个商品，如果不修改代码是无法完成的</p><h4 id="3-2工厂方法模式"><a href="#3-2工厂方法模式" class="headerlink" title="3.2工厂方法模式"></a>3.2工厂方法模式</h4><p>就是把车工厂再抽象为一个接口，不同类的车有自己的车工厂；</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    Car <span class="title function_">getCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaZhongFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dazhong</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是大众的工厂，如果想要加新的产品，直接创建一个工厂，继承总的车工厂接口就行</p><p>然后在消费者端创建想要的车工厂就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DaZhongFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaZhongFactory</span>();</span><br><span class="line">        factory.getCar().name();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3小结"><a href="#3-3小结" class="headerlink" title="3.3小结"></a>3.3小结</h4><p>简单工厂模式（静态工厂模式）</p><ul><li>虽然某种程度上不符合设计原则，但实际使用很多</li></ul><p>工厂方法模式</p><ul><li>不修改已有类的前提下，通过添加新的工厂实现拓展类。</li></ul><p>抽象工厂模式</p><ul><li>不可以增加产品，可以增加产品族</li></ul><p>应用场景：</p><ul><li>JDK中Calendar的getInstance方法</li><li>JDBC中的Connection对象的获取</li><li>Spring中IOC容器创建管理bean对象</li><li>反射中Class对象的newInstance方法</li></ul><h3 id="4抽象工厂模式"><a href="#4抽象工厂模式" class="headerlink" title="4抽象工厂模式"></a>4抽象工厂模式</h3><p>定义：抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类</p><p>适应场景：</p><ul><li>客户端（应用层）不依赖于产品类实例如何被创建、实现等细节</li><li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复代码</li><li>提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体的实现</li></ul><p>优点：</p><ul><li>具体产品在应用层的代码隔离，无需关心创建的细节</li><li>将一些列的产品统一到一起创建</li></ul><p>缺点：</p><ul><li>规定了所有可能被创建的产品集合，产品簇中拓展新的产品困难</li><li>增加了系统的抽象性和理解难度</li></ul><p>抽象工厂就是工厂的工厂。</p><p>比如说电子类有手机和路由器这两个产品。抽象工厂就在接口中定义这两样产品。</p><p>有这两个产品的有华为和小米，它们再创建工厂去继承这个比如说</p><p>定义产品的具体实现接口功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IphoneProduct</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> abstract1;</span><br><span class="line"><span class="comment">//抽象产品工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IProductFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    IphoneProduct <span class="title function_">iphoneProduct</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//生产路由器</span></span><br><span class="line">    IRouteProduct <span class="title function_">irouteProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同品牌实现这些功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title class_">IphoneProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开机小米&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关机，小米&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话，小米&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信。小米&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiPhone</span>  <span class="keyword">implements</span> <span class="title class_">IphoneProduct</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开机，华为&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关机，华为&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话，华为&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信，华为&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后一个抽象工厂接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstract1;</span><br><span class="line"><span class="comment">//抽象产品工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IProductFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    IphoneProduct <span class="title function_">iphoneProduct</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//生产路由器</span></span><br><span class="line">    IRouteProduct <span class="title function_">irouteProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由它再生产出工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title class_">IProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IphoneProduct <span class="title function_">iphoneProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRouteProduct <span class="title function_">irouteProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiRoute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title class_">IProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IphoneProduct <span class="title function_">iphoneProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRouteProduct <span class="title function_">irouteProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiRoute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5建造者模式"><a href="#5建造者模式" class="headerlink" title="5建造者模式"></a>5建造者模式</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式。</p><ul><li>定义：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示</li><li>主要作用：在用户不知道对象的构造过程和细节的情况下就可以直接创建复杂的对象</li></ul><p>用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象</p><p>例子：</p><ul><li>工厂（建造者模式）：负责制造汽车（组装过程和细节在工厂内）</li><li>汽车购买者（用户）：你只需要说出你需要的型号（对象的类型和内容），然后购买就可以使用了（不需要知道汽车是怎么组装的）</li></ul><p>Builder相当于图纸，是抽象的。比如建房子，Builder记录建房子的步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span>;<span class="comment">//地基</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span>;<span class="comment">//钢筋</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span>;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildD</span><span class="params">()</span>;<span class="comment">//粉刷</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Product是一个产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String buildA;</span><br><span class="line">    <span class="keyword">private</span> String buildB;</span><br><span class="line">    <span class="keyword">private</span> String buildC;</span><br><span class="line">    <span class="keyword">private</span> String buildD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildA</span><span class="params">(String buildA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildA = buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildB</span><span class="params">(String buildB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildB = buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildC</span><span class="params">(String buildC)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildC = buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildD</span><span class="params">(String buildD)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildD = buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;buildA=&#x27;&quot;</span> + buildA + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildB=&#x27;&quot;</span> + buildB + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildC=&#x27;&quot;</span> + buildC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildD=&#x27;&quot;</span> + buildD + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Woker是一个工人需要完成图纸上的任务，因此它需要继承Builder类，完成里面的工作。产品也是这这个类中new出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildA(<span class="string">&quot;地基&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;地基&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildB(<span class="string">&quot;钢筋工程&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;钢筋工程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildC(<span class="string">&quot;铺电线&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;铺电线&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildD</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setBuildD(<span class="string">&quot;粉刷&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;粉刷&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Direct是指挥，否则让工人按照步骤完成这些工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder;</span><br><span class="line"><span class="comment">//指挥：核心。负责指挥如何构建一个工程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">build</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        builder.buildA();</span><br><span class="line">        builder.buildB();</span><br><span class="line">        builder.buildC();</span><br><span class="line">        builder.buildD();</span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Director director=<span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">build</span> <span class="operator">=</span> director.build(<span class="keyword">new</span> <span class="title class_">Worker</span>());</span><br><span class="line">        System.out.println(build.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>上面示例是Builder模式常规用法，导演类Director在Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制先后次序，并向调用者返回完整的产品类。但有时候需要简化系统结构，可以把Director和抽象建造者进行结合</p></li><li><p>通过静态内部类的方式实现零件无序装配构造更加灵活</p></li></ul><p>如Builder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Builder <span class="title function_">buildA</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> Builder <span class="title function_">buildB</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> Builder <span class="title function_">buildC</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> Builder <span class="title function_">buildD</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>产品依旧,不过设置默认值，如果客户不修改的话，按默认值输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品：套餐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String BuildA=<span class="string">&quot;汉堡&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String BuildB=<span class="string">&quot;可乐&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String BuildC=<span class="string">&quot;薯条&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String BuildD=<span class="string">&quot;甜点&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BuildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildA</span><span class="params">(String buildA)</span> &#123;</span><br><span class="line">        BuildA = buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BuildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildB</span><span class="params">(String buildB)</span> &#123;</span><br><span class="line">        BuildB = buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BuildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildC</span><span class="params">(String buildC)</span> &#123;</span><br><span class="line">        BuildC = buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBuildD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BuildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuildD</span><span class="params">(String buildD)</span> &#123;</span><br><span class="line">        BuildD = buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;BuildA=&#x27;&quot;</span> + BuildA + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, BuildB=&#x27;&quot;</span> + BuildB + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, BuildC=&#x27;&quot;</span> + BuildC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, BuildD=&#x27;&quot;</span> + BuildD + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Woker实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Builder <span class="title function_">buildA</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        product.setBuildA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Builder <span class="title function_">buildB</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        product.setBuildA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Builder <span class="title function_">buildC</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        product.setBuildA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Builder <span class="title function_">buildD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        product.setBuildA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">ni</span> <span class="operator">=</span> worker.buildA(<span class="string">&quot;ni&quot;</span>).getProduct();</span><br><span class="line">        System.out.println(ni);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>产品的构建和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部的细节。</li><li>将复杂产品的创建步骤分解在不同的方法中，使创建过程更加清晰</li><li>具体的构建者之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有的类库的代码。符合“开闭原则”</li></ul><p>缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的相同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>需要生产的产品对象有复杂的内部结构，这些产品对象具备共性；</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</li><li>适合于一个具有较多的零件（属性）的产品（对象）的创建过程。</li></ul><h4 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h4><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整对象</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，对部件的组装成一部完整的汽车</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的六种状态（java）</title>
      <link href="/2022/07/12/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%88java%EF%BC%89/"/>
      <url>/2022/07/12/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%88java%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="1线程六种状态"><a href="#1线程六种状态" class="headerlink" title="1线程六种状态"></a>1线程六种状态</h3><ol><li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li><li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li>阻塞(BLOCKED)：表示线程阻塞于锁。</li><li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>计时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li>终止(TERMINATED)：表示该线程已经执行完毕。</li></ol><p>可以通过getState()方法获取线程当前状态。任何线程当前只能属于一种状态。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/19.jpeg" alt="19"></p><h4 id="1-初始状态-NEW"><a href="#1-初始状态-NEW" class="headerlink" title="1. 初始状态(NEW)"></a><strong>1. 初始状态(NEW)</strong></h4><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p><h4 id="2运行状态"><a href="#2运行状态" class="headerlink" title="2运行状态"></a>2运行状态</h4><ul><li>就绪状态(RUNNABLE之READY)</li></ul><p>​        就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。<br>​        调用线程的start()方法，此线程进入就绪状态。<br>​        当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。<br>​        当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。<br>​        锁池里的线程拿到对象锁后，进入就绪状态。</p><ul><li><p><strong>运行中状态(RUNNABLE之RUNNING)</strong></p><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</p></li></ul><h4 id="3被阻塞状态（Blocked）"><a href="#3被阻塞状态（Blocked）" class="headerlink" title="3被阻塞状态（Blocked）"></a>3被阻塞状态（Blocked）</h4><p>从Runnable状态进入Blocked状态只有一种途径，就是进入到Synchronized代码块中未获得相应的monitor锁。</p><h4 id="4等待状态-Waiting"><a href="#4等待状态-Waiting" class="headerlink" title="4等待状态(Waiting)"></a>4等待状态(Waiting)</h4><p>waiting方法的进入方式有三种：</p><p>1）当线程中调用了没有设置TimeOut参数的Object.wait()方法</p><p>2）调用Thread.join方法</p><p>3）调用了LockSupport.park()方法</p><blockquote><p>关于LockSupport.park()方法，Blocked是针对synchronized中monitor锁的，但在java中还有其他锁。比如说ReentrantLock等，在这些线程中，如果线程没有获取到锁会直接进入waiting状态，其实这种方法本质就是使用LockSupport.park()方法进入waiting状态</p></blockquote><ul><li>Blocked与waiting的区别<ul><li>Blocked是在等待其他线程释放monitor锁</li><li>waiting则是在等待某个条件。比如说join的线程执行完毕或者是notify()或者notifyAll()</li></ul></li></ul><h4 id="5计时等待状态-Timed-Waiting"><a href="#5计时等待状态-Timed-Waiting" class="headerlink" title="5计时等待状态(Timed Waiting)"></a>5计时等待状态(Timed Waiting)</h4><p>和waiting状态相似，区别在于是否有时间限制。Timed waiting 状态时会等待超时，之后由系统唤醒，也可以提前通知唤醒notify().</p><p>线程进入Timed Waiting状态：</p><ol><li>线程执行了设置参数的Thread.sleep(long millis)方法;</li></ol><ol start="2"><li>线程执行了设置参数的Object.wait(long timeout)方法；</li><li>线程执行了设置参数的Thread.join(long millis)方法；</li><li>线程执行了设置参数的LockSupport.parkNanos(long nanos)方法和LockSupport.parkUntil(long deadline)方法</li></ol><h3 id="2-线程状态间的相互转换"><a href="#2-线程状态间的相互转换" class="headerlink" title="2.线程状态间的相互转换"></a>2.线程状态间的相互转换</h3><p>主要为Blocked、waiting、Time waiting三种状态的转换，以及他们时如何进入下一个状态最终进入Runnable</p><h4 id="Blocked进入Runnable"><a href="#Blocked进入Runnable" class="headerlink" title="Blocked进入Runnable"></a>Blocked进入Runnable</h4><ul><li>想要Blocked状态进入Runnable状态，需要获得monitor锁。但如果想进入到其他状态比较特殊，因为它没有超时机制，所以不会主动进入</li></ul><h4 id="Waiting-进入Runnable-状态"><a href="#Waiting-进入Runnable-状态" class="headerlink" title="Waiting 进入Runnable 状态"></a>Waiting 进入Runnable 状态</h4><ul><li><p>只有当执行了LockSupport.unpark()，或者join的线程运行结束、或者被中断时才可以进入Runnable状态</p></li><li><p>如果其他线程通过调用notify()或者notifyAll()来唤醒它，则它会直接进入Blocked()状态。这是因为唤醒waiting线程的线程调用notify()或者notifyAll().必须要求持有monitor锁，也就是说wait()、notify()方法必须在Synchronized代码块中</p></li><li><p>所以处于waiting状态的线程被唤醒时拿不到该锁，就会进入到Blocked状态。直到执行了notify()&#x2F;notifyAll()方法的线程执行完毕后释放monitor锁。才有可能轮到它去抢夺这把锁.如果抢到。就会从Blocked状态回到Runnable状态</p></li></ul><p>对于Timed Waiting而言，它存在超时机制，也就是说如果超时时间到了那么就会系统自动直接拿到锁，或者join的线程执行结束&#x2F;调用了LockSupport.unpark()&#x2F;被中断等情况都会直接进入runnable</p><h3 id="6Terminated终止"><a href="#6Terminated终止" class="headerlink" title="6Terminated终止"></a>6Terminated终止</h3><p>想要进入这种状态只有两种方法：</p><ul><li>run()方法执行完毕</li><li>出现一个没有捕获的异常，终止了run()方法，最终意外终止</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流式编程</title>
      <link href="/2022/04/15/Stream%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/04/15/Stream%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>stream是用于对迭代器的增强，使之完成更高效的聚合操作（过滤，排序，统计分组）或者大批量数据操作。</p><p>stream和lambada表示结合后会大大提升编程效率。</p><p>通过将集合转换为这么一种叫做 “流” 的元素序列，通过声明性方式，能够对集合中的每个元素进行一系列并行或串行的流水线操作。</p><p>比如过滤保留部分元素、对元素进行排序、类型转换等；最后再进行一个终端操作，可以把 Stream 转换回集合类型，也可以直接对其中的各个元素进行处理，比如打印、比如计算总数、计算最大值等等。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0001.png" alt="stream"></p><h2 id="一分类"><a href="#一分类" class="headerlink" title="一分类"></a>一分类</h2><p>Stream提供方法很多，按照调用当前方法是否结束流处理，可以分为中间操作和结束操作。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0002.png" alt="stream" style="zoom:50%;" /><h3 id="1中间操作"><a href="#1中间操作" class="headerlink" title="1中间操作"></a>1中间操作</h3><ul><li>无状态操作：指当前元素的操作不受前面元素的影响，前后数据是否有依赖关系。</li><li>有状态操作：指当前元素的操作需要等所有元素处理完之后才能进行。</li></ul><p>比如说：sort(),distinct()需要知道先前的数才能操作，属于有状态操作</p><h3 id="2结束操作"><a href="#2结束操作" class="headerlink" title="2结束操作"></a>2结束操作</h3><ul><li>短路操作:指不需要处理完全部的元素就可以结束。</li><li>非短路操作: 指必须处理完所有元素才能结束。</li></ul><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0003.png" alt="stream" style="zoom: 33%;" /><h3 id="3Stream流的三种创建方式"><a href="#3Stream流的三种创建方式" class="headerlink" title="3Stream流的三种创建方式"></a>3Stream流的三种创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1集合创建stream流是          集合名.stream();</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line"><span class="comment">//2数组创建stream流是           Arrays.stream(数组名)</span></span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3Stream 静态方法</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Stream&lt;String&gt; stream0 = Stream.of(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcde&quot;</span>, <span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">5</span>);</span><br><span class="line">stream2.forEach(r -&gt; System.out.print(r + <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream3 = Stream.generate(<span class="keyword">new</span> <span class="title class_">Random</span>()::nextInt).limit(<span class="number">3</span>);</span><br><span class="line">stream3.forEach(r -&gt; System.out.print(r + <span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="二无状态操作"><a href="#二无状态操作" class="headerlink" title="二无状态操作"></a>二无状态操作</h2><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0005.png" alt="stream" style="zoom: 33%;" /><h3 id="2-1-map"><a href="#2-1-map" class="headerlink" title="2.1. map"></a>2.1. map</h3><p>接收一个函数作为入参，把这个函数应用到每个元素上，执行结果组成一个新的 stream 返回。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0004.png" alt="stream" style="zoom:50%;" /><p>例子1：对整数数组每个元素加 3 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=Array.asList(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">list.stream().map(v-&gt;v+<span class="number">3</span>).collect(Collectors.toList);</span><br></pre></td></tr></table></figure><p>结果为：</p><blockquote><p>8 5 6 4 7</p></blockquote><p>例子2: 把字符数组每个元素都变成大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;abs&quot;</span>, <span class="string">&quot;sds&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    List&lt;String&gt; collect = list.stream().map(s -&gt; s.toUpperCase(Locale.ROOT)).collect(Collectors.toList());</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><blockquote><p>[ABS, SDS, HELLO]</p></blockquote><h3 id="2-2-mapToXXX"><a href="#2-2-mapToXXX" class="headerlink" title="2.2 mapToXXX"></a>2.2 mapToXXX</h3><p>包括三个方法：mapToInt、mapToDouble、mapToLong</p><p>案例 3：把字符串数组转为整数数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcde&quot;</span>, <span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"><span class="type">int</span>[] newList = list.stream().mapToInt(r -&gt; r.length()).toArray();</span><br><span class="line">System.out.println(<span class="string">&quot;newList:&quot;</span> + Arrays.toString(newList));</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>newList:[2, 3, 4, 5, 6]</p></blockquote><h3 id="2-3-flatMap"><a href="#2-3-flatMap" class="headerlink" title="2.3 flatMap"></a>2.3 flatMap</h3><p>flatMap接收函数作为入参，然后把集合中每个元素转换成一个 stream，再把这些 stream 组成一个新的 stream，是拆分单词很好的工具。如下图：</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0008.png" alt="stream" style="zoom:50%;" /><p>案例 4：把一个字符串数组转成另一个字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;ab-abc-abcd-abcde-abcdef&quot;</span>, <span class="string">&quot;5-2-3-1-4&quot;</span>);</span><br><span class="line">List&lt;String&gt; newList = list.stream().flatMap(s -&gt; Arrays.stream(s.split(<span class="string">&quot;-&quot;</span>))).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;newList：&quot;</span> + newList);</span><br></pre></td></tr></table></figure><p>上面代码输出结果：</p><blockquote><p>newList：[ab, abc, abcd, abcde, abcdef, 5, 2, 3, 1, 4]</p></blockquote><h3 id="2-4-flatMapToXXX"><a href="#2-4-flatMapToXXX" class="headerlink" title="2.4 flatMapToXXX"></a>2.4 flatMapToXXX</h3><p>类似于 flatMap，返回一个 XXXStream。</p><p>包括三个方法：flatMapToInt、flatMapToLong、flatMapToDouble</p><p>案例 5：对给定的二维整数数组求和:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] data = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> Arrays.stream(data).flatMapToInt(a -&gt; Arrays.stream(a));</span><br><span class="line"><span class="type">int</span>[] ints = intStream.map(a -&gt; a + <span class="number">1</span>).toArray();</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>[2, 3, 4, 5, 6, 7]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] data = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> Arrays.stream(data).flatMapToInt(row -&gt; Arrays.stream(row));</span><br><span class="line">System.out.println(intStream.sum());</span><br></pre></td></tr></table></figure><p>​    输出</p><blockquote><p>21</p></blockquote><h3 id="2-5-filter"><a href="#2-5-filter" class="headerlink" title="2.5 filter"></a>2.5 filter</h3><p>筛选功能，按照一定的规则将符合条件的元素提取到新的流中。</p><p>定义一个学生类，包含姓名、年龄、性别、考试成绩四个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer age, String sex, Integer score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getters/setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例 6：找出考试成绩在 90 分以上的学生姓名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">10</span>, <span class="string">&quot;male&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">13</span>,<span class="string">&quot;male&quot;</span>, <span class="number">90</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="number">15</span>,<span class="string">&quot;female&quot;</span>, <span class="number">100</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jessie&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">78</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Allon&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">92</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alis&quot;</span>, <span class="number">22</span>,<span class="string">&quot;female&quot;</span>, <span class="number">50</span>));</span><br><span class="line">List&lt;String&gt;list=students.stream().filter(a-&gt;a.get(score)&gt;<span class="number">90</span>).map(a-&gt;a.getName()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"> System.out.println(list);</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p>[Jack, Lucy, Allon]</p></blockquote><h3 id="2-6-peek"><a href="#2-6-peek" class="headerlink" title="2.6 peek"></a>2.6 peek</h3><p>返回由 stream 中元素组成的新 stream，用给定的函数作用在新 stream 的每个元素上。传入的函数是一个 Consume  类型的，没有返回值，因此并不会改变原 stream 中元素的值。peek 主要用是 debug，可以方便地 查看流处理结果是否正确。</p><p>案例 7：过滤出 stream 中长度大于 3 的字符串并转为大写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>)</span><br><span class="line">             .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">             .peek(e -&gt; System.out.println(<span class="string">&quot;Filtered value: &quot;</span> + e))</span><br><span class="line">             .map(String::toUpperCase)</span><br><span class="line">             .peek(e -&gt; System.out.println(<span class="string">&quot;Mapped value: &quot;</span> + e))</span><br><span class="line">             .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><blockquote><p>Filtered value: three </p><p>Mapped value: THREE </p><p>Filtered value: four </p><p>Mapped value: FOUR</p></blockquote><h3 id="2-7-unordered"><a href="#2-7-unordered" class="headerlink" title="2.7 unordered"></a>2.7 unordered</h3><p>把一个有序的 stream 转成一个无序 stream ，如果原 stream 本身就是无序的，可能会返回原始的 stream。</p><p>案例 8：把一个有序数组转成无序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">                .parallelStream()<span class="comment">//并行编程。只有并行编程时才无序</span></span><br><span class="line">                .unordered()</span><br><span class="line">                .forEach(r -&gt; System.out.print(r + <span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure><p>每次执行输出的结果不一样，下面是一次输出的结果：</p><blockquote><p>3 5 4 2 1</p></blockquote><h2 id="三-有状态操作"><a href="#三-有状态操作" class="headerlink" title="三 有状态操作"></a>三 有状态操作</h2><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0006.png" alt="stream" style="zoom:50%;" /><h3 id="3-1-distinct"><a href="#3-1-distinct" class="headerlink" title="3.1 distinct"></a>3.1 distinct</h3><p>去重功能。</p><p>案例 9 ：去掉字符串数组中的重复字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; newList = Arrays.stream(array).distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;newList:&quot;</span> + newList);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>newList:[a, b, c, d, e]</p></blockquote><h3 id="3-2-limit"><a href="#3-2-limit" class="headerlink" title="3.2 limit"></a>3.2 limit</h3><p>限制从 stream 中获取前 n 个元素。</p><p>案例 10 ：从数组中获取前 5 个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; newList = Arrays.stream(array).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;newList:&quot;</span> + newList);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>newList:[c, c, a, b, b]</p></blockquote><h3 id="3-3-skip"><a href="#3-3-skip" class="headerlink" title="3.3 skip"></a>3.3 skip</h3><p>跳过 Stream 中前 n 个元素</p><p>案例 11：从数组中获取第 5 个元素之后的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; newList = Arrays.stream(array).skip(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;newList:&quot;</span> + newList);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>newList:[f, g, h, i]</p></blockquote><h3 id="3-4-sorted"><a href="#3-4-sorted" class="headerlink" title="3.4 sorted"></a>3.4 sorted</h3><p>排序功能。</p><p>案例 12：对给定数组进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; newList = Arrays.stream(array).sorted().collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;newList:&quot;</span> + newList);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>newList:[a, b, b, c, c, d, d, e, e]</p></blockquote><p>案例 13：按照学生成绩进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">10</span>, <span class="string">&quot;male&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">13</span>,<span class="string">&quot;male&quot;</span>, <span class="number">90</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="number">15</span>,<span class="string">&quot;female&quot;</span>, <span class="number">100</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jessie&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">78</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Allon&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">92</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alis&quot;</span>, <span class="number">22</span>,<span class="string">&quot;female&quot;</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nameList = students.stream().sorted(Comparator.comparing(Student::getScore)).map(Student::getName).collect(Collectors.toList());</span><br><span class="line">System.out.print(<span class="string">&quot;按成绩排序输出学生姓名：&quot;</span> + nameList);</span><br></pre></td></tr></table></figure><blockquote><p>考试成绩90分以上的学生姓名：[Alis, Jessie, Mike, Jack, Allon, Lucy]</p></blockquote><h2 id="四短路操作"><a href="#四短路操作" class="headerlink" title="四短路操作"></a>四短路操作</h2><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0007.png" alt="stream" style="zoom:50%;" /><h3 id="4-1-findAny"><a href="#4-1-findAny" class="headerlink" title="4.1 findAny"></a>4.1 findAny</h3><p>找出 stream 中任何一个满足过滤条件的元素。</p><p>案例 14：找出任何一个成绩高于 90 分的学生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">10</span>, <span class="string">&quot;male&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">13</span>,<span class="string">&quot;male&quot;</span>, <span class="number">90</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="number">15</span>,<span class="string">&quot;female&quot;</span>, <span class="number">100</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jessie&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">78</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Allon&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">92</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alis&quot;</span>, <span class="number">22</span>,<span class="string">&quot;female&quot;</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">Optional&lt;Student&gt; studentFindAny = students.stream().filter(x -&gt; x.getScore() &gt; <span class="number">90</span>).findAny();</span><br><span class="line">System.out.print(<span class="string">&quot;找出任意一个考试成绩在90分以上的学生姓名：&quot;</span> + studentFindAny.orElseGet(<span class="literal">null</span>).getName());</span><br></pre></td></tr></table></figure><blockquote><p>找出任意一个考试成绩在90分以上的学生姓名：Lucy</p></blockquote><h3 id="4-2-anyMatch"><a href="#4-2-anyMatch" class="headerlink" title="4.2 anyMatch"></a>4.2 anyMatch</h3><p>是否存在任意一个满足给定条件的元素。</p><p>案例 15：是否存在成绩高于 90 分的学生，是否存在成绩低于 50 分的学生。还是采用上面案例 14 中的学生集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> students.stream().allMatch(x -&gt; x.getScore() &gt; <span class="number">90</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否所有学生的成绩都高于90分：&quot;</span> + result1);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> students.stream().allMatch(x -&gt; x.getScore() &gt; <span class="number">50</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;是否所有学生的成绩都高于50分：&quot;</span> + result2);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>是否所有学生的成绩都高于90分：false</p><p>是否所有学生的成绩都高于50分：true</p></blockquote><h3 id="4-3-allMatch"><a href="#4-3-allMatch" class="headerlink" title="4.3 allMatch"></a>4.3 allMatch</h3><p>是否集合中所有元素都满足给定的条件，如果集合是空，则返回 true。</p><p>案例 16：学生成绩是否都高于 90 分，是否都高于 50 分。还是采用上面案例 14 中的学生集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> students.stream().allMatch(x -&gt; x.getScore() &gt; <span class="number">90</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是否所有学生的成绩都高于90分：&quot;</span> + result1);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> students.stream().allMatch(x -&gt; x.getScore() &gt; <span class="number">50</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;是否所有学生的成绩都高于50分：&quot;</span> + result2);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>是否所有学生的成绩都高于90分：false</p><p>是否所有学生的成绩都高于50分：true</p></blockquote><h3 id="4-4-noneMatch"><a href="#4-4-noneMatch" class="headerlink" title="4.4 noneMatch"></a>4.4 noneMatch</h3><p>是否没有元素能匹配给定的条件，如果集合是空，则返回 true。</p><p>案例 17：是不是没有学生成绩在 90 分以上，是否没有学生成绩在 50 分以下。还是采用上面案例 14 中的学生集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> students.stream().noneMatch(x -&gt; x.getScore() &gt; <span class="number">90</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;是不是没有学生成绩在 90 分以上：&quot;</span> + result1);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> students.stream().noneMatch(x -&gt; x.getScore() &lt; <span class="number">50</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;是不是没有学生成绩在 50 分以下：&quot;</span> + result2);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>是不是没有学生成绩在 90 分以上：false</p><p>是不是没有学生成绩在 50 分以下：true</p></blockquote><h3 id="4-5-findFirst"><a href="#4-5-findFirst" class="headerlink" title="4.5 findFirst"></a>4.5 findFirst</h3><p>找出第一个符合条件的元素。</p><p>案例 18：找出第一个成绩在 90 分以上的学生。还是采用上面案例 14 中的学生集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; studentFindAny = students.stream().filter(x -&gt; x.getScore() &gt; <span class="number">90</span>).findFirst();</span><br><span class="line">System.out.print(<span class="string">&quot;第一个成绩在 90 分以上的学生姓名：&quot;</span> + studentFindAny.orElseGet(<span class="literal">null</span>).getName());</span><br><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>第一个成绩在 90 分以上的学生姓名：Lucy</p></blockquote><h2 id="五非短路操作"><a href="#五非短路操作" class="headerlink" title="五非短路操作"></a>五非短路操作</h2><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0009.png" alt="stream" style="zoom:50%;" /><h3 id="5-1-forEach"><a href="#5-1-forEach" class="headerlink" title="5.1 forEach"></a>5.1 forEach</h3><p>遍历元素。</p><p>案例 19：遍历一个数组并打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; array = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">array.stream().forEach(System.out :: println);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>5 2 3 1 4</p></blockquote><h3 id="5-2-forEachOrdered"><a href="#5-2-forEachOrdered" class="headerlink" title="5.2 forEachOrdered"></a>5.2 forEachOrdered</h3><p>按照给定集合中元素的顺序输出。主要使用场景是在并行流的情况下，按照给定的顺序输出元素。</p><p>案例 20：用并行流遍历一个数组并按照给定数组的顺序输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; array = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">array.parallelStream().forEachOrdered(System.out :: println);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>5 2 3 1 4</p></blockquote><h3 id="5-3-toArray"><a href="#5-3-toArray" class="headerlink" title="5.3 toArray"></a>5.3 toArray</h3><p>返回包括给定 stream 中所有元素的数组。</p><p>案例 21：把给定字符串流转化成数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcde&quot;</span>, <span class="string">&quot;abcdef&quot;</span>).stream();</span><br><span class="line">String[] newArray1 = stream.toArray(str -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>]);</span><br><span class="line">String[] newArray2 = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">Object[] newArray3 = stream.toArray();</span><br></pre></td></tr></table></figure><h3 id="5-4-reduce"><a href="#5-4-reduce" class="headerlink" title="5.4 reduce"></a>5.4 reduce</h3><p>规约操作，把一个流的所有元素合并成一个元素，比如求和、求乘积、求最大最小值等。</p><p>案例 22：求整数数组元素之和、乘积和最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class="line">Optional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class="line">Optional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">System.out.println(<span class="string">&quot;数组元素之和：&quot;</span> + sum.get());</span><br><span class="line">System.out.println(<span class="string">&quot;数组元素乘积：&quot;</span> + product.get());</span><br><span class="line">System.out.println(<span class="string">&quot;数组元素最大值：&quot;</span> + max.get());</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>数组元素之和：15</p><p>数组元素乘积：120 </p><p>数组元素最大值：5</p></blockquote><p>案例 23：求全班学生最高分、全班学生总分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">10</span>, <span class="string">&quot;male&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">13</span>,<span class="string">&quot;male&quot;</span>, <span class="number">90</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="number">15</span>,<span class="string">&quot;female&quot;</span>, <span class="number">100</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jessie&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">78</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Allon&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">92</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alis&quot;</span>, <span class="number">22</span>,<span class="string">&quot;female&quot;</span>, <span class="number">50</span>));</span><br><span class="line">Optional&lt;Integer&gt; maxScore = students.stream().map(r -&gt; r.getScore()).reduce(Integer::max);</span><br><span class="line">Optional&lt;Integer&gt; sumScore = students.stream().map(r -&gt; r.getScore()).reduce(Integer::sum);</span><br><span class="line">System.out.println(<span class="string">&quot;全班学生最高分：&quot;</span> + maxScore.get());</span><br><span class="line">System.out.println(<span class="string">&quot;全班学生总分：&quot;</span> + sumScore.get());</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>全班学生最高分：100 </p><p>全班学生总分：498</p></blockquote><h3 id="5-5-collect"><a href="#5-5-collect" class="headerlink" title="5.5 collect"></a>5.5 collect</h3><p>把 stream 中的元素归集到新的集合或者归集成单个元素。</p><h4 id="5-5-1-归集成新集合"><a href="#5-5-1-归集成新集合" class="headerlink" title="5.5.1 归集成新集合"></a>5.5.1 归集成新集合</h4><p>方法包括 toList、toSet、toMap。</p><p>案例 24：根据学生列表，归纳出姓名列表、不同分数列表、姓名分数集合，其中 Mike 和 Jessie 的分数都是 88。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">10</span>, <span class="string">&quot;male&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">13</span>,<span class="string">&quot;male&quot;</span>, <span class="number">90</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="number">15</span>,<span class="string">&quot;female&quot;</span>, <span class="number">100</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jessie&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Allon&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">92</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alis&quot;</span>, <span class="number">22</span>,<span class="string">&quot;female&quot;</span>, <span class="number">50</span>));</span><br><span class="line">List&lt;String&gt; list = students.stream().map(r -&gt; r.getName()).collect(Collectors.toList());</span><br><span class="line">Set&lt;Integer&gt; set = students.stream().map(r -&gt; r.getScore()).collect(Collectors.toSet());</span><br><span class="line">Map&lt;String, Integer&gt; map = students.stream().collect(Collectors.toMap(Student::getName, Student::getScore));</span><br><span class="line">System.out.println(<span class="string">&quot;全班学生姓名列表：&quot;</span> + list);</span><br><span class="line">System.out.println(<span class="string">&quot;全班学生不同分数列表：&quot;</span> + set);</span><br><span class="line">System.out.println(<span class="string">&quot;全班学生姓名分数集合：&quot;</span> + map);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>全班学生姓名列表：[Mike, Jack, Lucy, Jessie, Allon, Alis] </p><p>全班学生不同分数列表：[50, 100, 88, 90, 92] </p><p>全班学生姓名分数集合：{Mike&#x3D;88, Allon&#x3D;92, Alis&#x3D;50, Lucy&#x3D;100, Jack&#x3D;90, Jessie&#x3D;88}</p></blockquote><h4 id="5-5-2-统计功能"><a href="#5-5-2-统计功能" class="headerlink" title="5.5.2 统计功能"></a>5.5.2 统计功能</h4><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0010.png" alt="stream" style="zoom:50%;" /><p>统计功能包括如下方法：</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/stream/stream/0011.png" alt="stream" style="zoom:50%;" /><p>   案例 25：求总数、求和、最大&#x2F;最小&#x2F;平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().collect(Collectors.counting());</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().collect(Collectors.summingInt(r -&gt; r));</span><br><span class="line"><span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingDouble(r -&gt; r));</span><br><span class="line">Optional&lt;Integer&gt; max = list.stream().collect(Collectors.maxBy(Integer::compare));</span><br><span class="line">Optional&lt;Integer&gt; min = list.stream().collect(Collectors.maxBy((x, y) -&gt; x &gt; y ? y : x));</span><br><span class="line">System.out.println(<span class="string">&quot;总数:&quot;</span> + count);</span><br><span class="line">System.out.println(<span class="string">&quot;总和:&quot;</span> + sum);</span><br><span class="line">System.out.println(<span class="string">&quot;平均值:&quot;</span> + average);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值:&quot;</span> + max.get());</span><br><span class="line">System.out.println(<span class="string">&quot;最小值:&quot;</span> + min.get());</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>总数:5 </p><p>总和:15 </p><p>平均值:3.0 </p><p>最大值:5 </p><p>最小值:5</p></blockquote><p>案例 26：求总和统计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> list.stream().collect(Collectors.summarizingInt(r -&gt; r));</span><br><span class="line">System.out.println(<span class="string">&quot;综合统计结果：&quot;</span> + statistics.toString());</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>综合统计结果：IntSummaryStatistics{count&#x3D;5, sum&#x3D;15, min&#x3D;1, average&#x3D;3.000000, max&#x3D;5}</p></blockquote><h4 id="5-5-3-分区和分组"><a href="#5-5-3-分区和分组" class="headerlink" title="5.5.3 分区和分组"></a>5.5.3 分区和分组</h4><p>主要包括两个函数：</p><ul><li>partitioningBy：把 stream 分成两个 map</li><li>groupingBy：把 stream 分成多个 map</li></ul><p>案例 27：将学生按照 80 分以上和以下分区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">10</span>, <span class="string">&quot;male&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">10</span>,<span class="string">&quot;male&quot;</span>, <span class="number">90</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">100</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jessie&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">78</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Allon&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">92</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alis&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">50</span>));</span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; partitionByScore = students.stream().collect(Collectors.partitioningBy(x -&gt; x.getScore() &gt; <span class="number">80</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;将学生按照考试成绩80分以上分区：&quot;</span>);</span><br><span class="line">partitionByScore.forEach((k,v ) -&gt; &#123;</span><br><span class="line">    System.out.print(k ? <span class="string">&quot;80分以上：&quot;</span> : <span class="string">&quot;80分以下：&quot;</span>);</span><br><span class="line">    v.forEach(r -&gt; System.out.print(r.getName() + <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><p>分区结果是把 Student 列表分成 key 只有 true 和 false 两个值的 map，输出如下：</p><blockquote><p>将学生按照考试成绩80分以上分区：</p><p>80分以下：Jessie,Alis,</p><p>80分以上：Mike,Jack,Lucy,Allon,</p></blockquote><p>案例 28：将学生按照性别、年龄分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; group = students.stream().collect(Collectors.groupingBy(Student::getSex, Collectors.groupingBy(Student::getAge)));</span><br><span class="line">System.out.println(<span class="string">&quot;将学生按照性别、年龄分组：&quot;</span>);</span><br><span class="line">group.forEach((k,v ) -&gt; &#123;</span><br><span class="line">    System.out.println(k +<span class="string">&quot;：&quot;</span>);</span><br><span class="line">    v.forEach((k1,v1) -&gt; &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;      &quot;</span> + k1 + <span class="string">&quot;:&quot;</span> );</span><br><span class="line">        v1.forEach(r -&gt; System.out.print(r.getName() + <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出如下：</p><blockquote><p>将学生按照性别、年龄分组：</p><p>female：</p><p>   16:Allon,Alis, </p><p>   12:Lucy,Jessie, </p><p>male：</p><p>   10:Mike,Jack,</p></blockquote><h4 id="5-5-4-连接"><a href="#5-5-4-连接" class="headerlink" title="5.5.4 连接"></a>5.5.4 连接</h4><p>将 stream 中的元素用指定的连接符合并，连接符可以是空。</p><p>案例 29：输出所有学生的姓名，用逗号分隔，这里还是使用案例 27 中的学生列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">studentNames</span> <span class="operator">=</span> students.stream().map(r -&gt; r.getName()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;所有学生姓名列表：&quot;</span> + studentNames);</span><br></pre></td></tr></table></figure><p>输出如下：</p><blockquote><p>所有学生姓名列表：Mike,Jack,Lucy,Jessie,Allon,Alis</p></blockquote><h4 id="5-5-5-规约"><a href="#5-5-5-规约" class="headerlink" title="5.5.5 规约"></a>5.5.5 规约</h4><p>在 5.4 节已经讲过规约了，这里的规约支持更强大的自定义规约。</p><p>案例 30：数组中每个元素加 1 后求总和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">listSum</span> <span class="operator">=</span> list.stream().collect(Collectors.reducing(<span class="number">0</span>, x -&gt; x + <span class="number">1</span>, (sum, b) -&gt; sum + b));</span><br><span class="line">System.out.println(<span class="string">&quot;数组中每个元素加 1 后总和：&quot;</span> + listSum);</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>数组中每个元素加 1 后总和：20</p></blockquote><h3 id="5-6-max、min、count"><a href="#5-6-max、min、count" class="headerlink" title="5.6 max、min、count"></a>5.6 max、min、count</h3><p>stream 提供的方便统计的方法。</p><p>案例 31：统计整数数组中最大值、最小值、大于 3 的元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数组元素最大值：&quot;</span>+list.stream().max(Integer::compareTo).get());</span><br><span class="line">System.out.println(<span class="string">&quot;数组元素最小值：&quot;</span>+list.stream().min(Integer::compareTo).get());</span><br><span class="line">System.out.println(<span class="string">&quot;数组中大于3的元素个数：&quot;</span>+list.stream().filter(x -&gt; x &gt; <span class="number">3</span>).count());</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>数组元素最大值：5</p><p>数组元素最小值：1</p><p>数组中大于3的元素个数：2</p></blockquote><p>案例 32：统计分数最高的学生姓名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">10</span>, <span class="string">&quot;male&quot;</span>, <span class="number">88</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">10</span>,<span class="string">&quot;male&quot;</span>, <span class="number">90</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">100</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jessie&quot;</span>, <span class="number">12</span>,<span class="string">&quot;female&quot;</span>, <span class="number">78</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Allon&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">92</span>));</span><br><span class="line">students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alis&quot;</span>, <span class="number">16</span>,<span class="string">&quot;female&quot;</span>, <span class="number">50</span>));</span><br><span class="line">Optional&lt;Student&gt; optional = students.stream().max(Comparator.comparing(r -&gt; r.getScore()));</span><br><span class="line">System.out.println(<span class="string">&quot;成绩最高的学生姓名：&quot;</span> + optional.get().getName());</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>成绩最高的学生姓名：Lucy</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Stream </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-04虚拟机栈</title>
      <link href="/2022/04/15/JVM-04%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
      <url>/2022/04/15/JVM-04%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="4虚拟机栈"><a href="#4虚拟机栈" class="headerlink" title="4虚拟机栈"></a>4虚拟机栈</h1><h2 id="1简介"><a href="#1简介" class="headerlink" title="1简介"></a>1简介</h2><h3 id="1-1虚拟机栈的出现背景"><a href="#1-1虚拟机栈的出现背景" class="headerlink" title="1.1虚拟机栈的出现背景"></a>1.1虚拟机栈的出现背景</h3><ol><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ol><h3 id="1-2内存中的栈与堆"><a href="#1-2内存中的栈与堆" class="headerlink" title="1.2内存中的栈与堆"></a>1.2内存中的栈与堆</h3><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0001%20%281%29.png" alt="jvm"></p><h3 id="1-3虚拟机栈基本内容"><a href="#1-3虚拟机栈基本内容" class="headerlink" title="1.3虚拟机栈基本内容"></a>1.3虚拟机栈基本内容</h3><p>Java虚拟机栈是什么？</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的,一个栈帧对应一个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0002.png" alt="jvm" style="zoom:67%;" /><ul><li>虚拟机栈的生命周期<ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li>虚拟机栈的作用<ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="1-4虚拟机栈的特点"><a href="#1-4虚拟机栈的特点" class="headerlink" title="1.4虚拟机栈的特点"></a>1.4虚拟机栈的特点</h3><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li>对于栈来说不存在垃圾回收问题<ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0003.png" alt="jvm"></p><h3 id="1-5虚拟机栈的异常"><a href="#1-5虚拟机栈的异常" class="headerlink" title="1.5虚拟机栈的异常"></a>1.5虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</li></ul></li></ul><h3 id="1-6设置栈内存大小"><a href="#1-6设置栈内存大小" class="headerlink" title="1.6设置栈内存大小"></a>1.6设置栈内存大小</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>官网地址: <a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p></blockquote><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><blockquote><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux&#x2F;x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris&#x2F;x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul></blockquote><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">默认情况下：count ： 11420</span></span><br><span class="line"><span class="comment">设置栈的大小： -Xss256k   count: 1875</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没设置参数前</strong></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10821</span></span><br><span class="line"><span class="number">10822</span></span><br><span class="line"><span class="number">10823</span></span><br><span class="line"><span class="number">10824</span></span><br><span class="line">*** java.lang.instrument ASSERTION FAILED ***: <span class="string">&quot;!errorOutstanding&quot;</span> with message transform method call failed at JPLISAgent.c line: <span class="number">844</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p><strong>设置栈参数之后</strong></p><p>设置参数方法：run–&gt;Edit Configurations-下图。如果没有vm option选项可以在Modify option中勾选出来</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0004.png" alt="jvm" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1873</span></span><br><span class="line"><span class="number">1874</span></span><br><span class="line"><span class="number">1875</span></span><br><span class="line">*** java.lang.instrument ASSERTION FAILED ***: <span class="string">&quot;!errorOutstanding&quot;</span> with message transform method call failed at JPLISAgent.c line: <span class="number">844</span></span><br></pre></td></tr></table></figure><h2 id="2栈的存储单位"><a href="#2栈的存储单位" class="headerlink" title="2栈的存储单位"></a>2栈的存储单位</h2><h3 id="2-1栈中存储什么？"><a href="#2-1栈中存储什么？" class="headerlink" title="2.1栈中存储什么？"></a>2.1栈中存储什么？</h3><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="2-2栈运行原理"><a href="#2-2栈运行原理" class="headerlink" title="2.2栈运行原理"></a>2.2栈运行原理</h3><ol><li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0005.png" alt="jvm"></p><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="2-3栈帧的内部结构"><a href="#2-3栈帧的内部结构" class="headerlink" title="2.3栈帧的内部结构"></a>2.3栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0006.png" alt="jvm"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0007.png" alt="jvm"></p><h2 id="3局部变量表"><a href="#3局部变量表" class="headerlink" title="3局部变量表"></a>3局部变量表</h2><h3 id="3-1认识局部变量表"><a href="#3-1认识局部变量表" class="headerlink" title="3.1认识局部变量表"></a>3.1认识局部变量表</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h4 id="2举例"><a href="#2举例" class="headerlink" title="2举例"></a>2举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalVariablesTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">        dateP = <span class="literal">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0008.png" alt="jvm"></p><p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p><h4 id="3部分详解"><a href="#3部分详解" class="headerlink" title="3部分详解"></a>3部分详解</h4><p>我们直接用jclasslib来看字节码，以main方法为例来讲解</p><p>1、0-15 也就是有16行字节码</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0009.png" alt="jvm"></p><p>2、方法异常信息表</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0010.png" alt="jvm"></p><p>3、Misc</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0011.png" alt="jvm"></p><p>4、行号表</p><p>Java代码的行号和字节码指令行号的对应关系</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0012.png" alt="jvm"></p><p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0013.png" alt="jvm"></p><p>1、图中圈的东西表示该局部变量的作用域</p><p>2、Start PC&#x3D;&#x3D;11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length&#x3D;&#x3D; 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 &#x3D;&#x3D;5。</p><p>4、<code>Ljava/lang/String</code> 前面的L表示引用类型</p><h3 id="3-2关于Slot的理解"><a href="#3-2关于Slot的理解" class="headerlink" title="3.2关于Slot的理解"></a>3.2关于Slot的理解</h3><ol><li><p>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</p></li><li><p>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，</p><p>32位以内的类型只占用一个slot</p><p>（包括returnAddress类型），</p><p>64位的类型占用两个slot</p><p>（1ong和double）。</p><ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</p></li><li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</p></li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0014.png" alt="jvm"></p><h4 id="1Slot代码示例"><a href="#1Slot代码示例" class="headerlink" title="1Slot代码示例"></a>1Slot代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>局部变量表：this 存放在 index &#x3D; 0 的位置</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0015.png" alt="jvm"></p><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">      dateP = <span class="literal">null</span>;</span><br><span class="line">      name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">      <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> dateP + name2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0016.png" alt="jvm"></p><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2Slot的重复利用"><a href="#2Slot的重复利用" class="headerlink" title="2Slot的重复利用"></a>2Slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量 c 重用了局部变量 b 的 slot 位置</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0017.png" alt="jvm"></p><h4 id="3静态变量与局部变量的对比"><a href="#3静态变量与局部变量的对比" class="headerlink" title="3静态变量与局部变量的对比"></a>3静态变量与局部变量的对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line"><span class="number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line"><span class="number">2</span>、按照在类中声明的位置分：</span><br><span class="line">  <span class="number">2</span>-<span class="number">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  <span class="number">2</span>-<span class="number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h4 id="4补充说明"><a href="#4补充说明" class="headerlink" title="4补充说明"></a>4补充说明</h4><ol><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ol><h2 id="4操作数栈"><a href="#4操作数栈" class="headerlink" title="4操作数栈"></a>4操作数栈</h2><h3 id="4-1操作数栈的特点"><a href="#4-1操作数栈的特点" class="headerlink" title="4.1操作数栈的特点"></a>4.1操作数栈的特点</h3><ol><li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li><li>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</li></ol><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0018.png" alt="jvm"></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0019.png" alt="jvm"></p><h3 id="4-2操作数栈的作用"><a href="#4-2操作数栈的作用" class="headerlink" title="4.2操作数栈的作用"></a>4.2操作数栈的作用</h3><ol><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0020.jpeg" alt="jvm"></p><p>局部变量表就相当于食材</p><p>操作数栈就相当于做法步骤</p><h2 id="5操作数栈代码追踪"><a href="#5操作数栈代码追踪" class="headerlink" title="5操作数栈代码追踪"></a>5操作数栈代码追踪</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">       <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0021.png" alt="jvm"></p><h3 id="5-1流程"><a href="#5-1流程" class="headerlink" title="5.1流程"></a>5.1流程</h3><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0022.png" alt="jvm"></p><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><ul><li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0023.png" alt="jvm"></p><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0024.png" alt="jvm"></p><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0025.png" alt="jvm"></p><p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0026.png" alt="jvm"></p><h3 id="5-2小问题"><a href="#5-2小问题" class="headerlink" title="5.2小问题"></a>5.2小问题</h3><p><strong>关于类型转换的说明</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0027.png" alt="jvm"></p><ul><li>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li><li>但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0028.png" alt="jvm"></p><ul><li>m改成800之后，byte存储不了，就成了short型，sipush 800</li></ul><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + n;</span><br><span class="line">      <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0029.png" alt="jvm"></p><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0030.png" alt="jvm"></p><h2 id="6栈顶缓存技术"><a href="#6栈顶缓存技术" class="headerlink" title="6栈顶缓存技术"></a>6栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></li><li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li></ol><h2 id="7动态链接"><a href="#7动态链接" class="headerlink" title="7动态链接"></a>7动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">10</span>; size <span class="number">712</span> bytes</span><br><span class="line">  MD5 checksum e56913c945f897c7ee6c0a608629bca8</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java1.DynamicLinkingTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">8.</span>#<span class="number">24</span>         <span class="comment">// com/atguigu/java1/DynamicLinkingTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// methodA()....</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">30</span>            <span class="comment">// methodB()....</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">31</span>         <span class="comment">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">32</span>            <span class="comment">// com/atguigu/java1/DynamicLinkingTest</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               num</span><br><span class="line">  #<span class="number">11</span> = Utf8               I</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">17</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">  #<span class="number">19</span> = Utf8               methodA</span><br><span class="line">  #<span class="number">20</span> = Utf8               methodB</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               <span class="title function_">methodA</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               <span class="title function_">methodB</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">19</span>:#<span class="number">13</span>        <span class="comment">// methodA:()V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String methodA()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String methodB()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method methodA:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        <span class="number">14</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        <span class="number">19</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li><code>#8 = Class #32</code> ：去找 #32</li><li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0031.png" alt="jvm"></p><p><strong>为什么要用常量池呢？</strong></p><ol><li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li><li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li></ol><h2 id="8方法的调用"><a href="#8方法的调用" class="headerlink" title="8方法的调用"></a>8方法的调用</h2><h3 id="8-1静态链接与动态链接"><a href="#8-1静态链接与动态链接" class="headerlink" title="8.1静态链接与动态链接"></a>8.1静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="8-2早期绑定与晚期绑定"><a href="#8-2早期绑定与晚期绑定" class="headerlink" title="8.2早期绑定与晚期绑定"></a>8.2早期绑定与晚期绑定</h3><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span> &#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部分字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokevirtual #<span class="number">2</span>                  <span class="comment">// Method com/atguigu/java2/Animal.eat:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokeinterface #<span class="number">3</span>,  <span class="number">1</span>            <span class="comment">// InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure><p>invokevirtual 体现为晚期绑定</p><p>invokeinterface 也体现为晚期绑定</p><p>invokespecial 体现为早期绑定</p><h3 id="8-3多态与绑定"><a href="#8-3多态与绑定" class="headerlink" title="8.3多态与绑定"></a>8.3多态与绑定</h3><ol><li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li><li>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li></ol><h4 id="1虚方法与非虚方法"><a href="#1虚方法与非虚方法" class="headerlink" title="1虚方法与非虚方法"></a>1虚方法与非虚方法</h4><p><strong>虚方法与非虚方法的区别</strong></p><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h4 id="2举例-1"><a href="#2举例-1" class="headerlink" title="2举例"></a>2举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也  会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MethodInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son 类中 show() 方法的字节码指令如下</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0032.png" alt="jvm"></p><h4 id="3关于-invokedynamic-指令"><a href="#3关于-invokedynamic-指令" class="headerlink" title="3关于 invokedynamic 指令"></a>3关于 invokedynamic 指令</h4><ol><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0033.png" alt="jvm"></p><h3 id="8-4动态语言和静态语言"><a href="#8-4动态语言和静态语言" class="headerlink" title="8.4动态语言和静态语言"></a>8.4动态语言和静态语言</h3><ol><li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li></ol><p>Java：String info &#x3D; “mogu blog”; (Java是静态类型语言的，会先编译就进行类型检查)<br>JS：var name &#x3D; “shkstart”; var name &#x3D; 10; （运行时才进行检查）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python: info = 130.5 (运行时才检查)</span><br></pre></td></tr></table></figure><h3 id="8-5Java语言中方法重写的本质"><a href="#8-5Java语言中方法重写的本质" class="headerlink" title="8.5Java语言中方法重写的本质"></a>8.5Java语言中方法重写的本质</h3><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><h3 id="8-6Java语言中方法重写的本质"><a href="#8-6Java语言中方法重写的本质" class="headerlink" title="8.6Java语言中方法重写的本质"></a>8.6Java语言中方法重写的本质</h3><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li><li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li></ol><h3 id="8-7-虚方法表"><a href="#8-7-虚方法表" class="headerlink" title="8.7 虚方法表"></a>8.7 虚方法表</h3><ol><li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li></ol><p><strong>例子1</strong></p><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0034.png" alt="jvm"></p><p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p><p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p><p><strong>例子2</strong></p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0035.png" alt="jvm" style="zoom: 50%;" /><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0036.jpeg" alt="jvm" style="zoom:75%;" /><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0037.jpeg" alt="jvm" style="zoom:75%;" /><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0038.jpeg" alt="jvm" style="zoom:75%;" /><h2 id="9方法返回地址"><a href="#9方法返回地址" class="headerlink" title="9方法返回地址"></a>9方法返回地址</h2><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0039.png" alt="jvm"></p><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息 也叫做帧数据区</p></blockquote><ol><li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li><li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ol><p><strong>方法退出的两种方式</strong></p><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><p><strong>正常退出：</strong></p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li><li>lreturn：Long类型</li><li>freturn：Float类型</li><li>dreturn：Double类型</li><li>areturn：引用类型</li><li>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li></ul></li></ol><p><strong>异常退出：</strong></p><ol><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</li><li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0040.png" alt="jvm"></p><p>异常处理表：</p><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/jvm04/0041.png" alt="jvm"></p><h2 id="10一些附加信息"><a href="#10一些附加信息" class="headerlink" title="10一些附加信息"></a>10一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息</p><h2 id="11栈相关面试题"><a href="#11栈相关面试题" class="headerlink" title="11栈相关面试题"></a>11栈相关面试题</h2><h3 id="1举例栈溢出的情况？"><a href="#1举例栈溢出的情况？" class="headerlink" title="1举例栈溢出的情况？"></a>1举例栈溢出的情况？</h3><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h3 id="2调整栈大小，就能保证不出现溢出么？"><a href="#2调整栈大小，就能保证不出现溢出么？" class="headerlink" title="2调整栈大小，就能保证不出现溢出么？"></a>2调整栈大小，就能保证不出现溢出么？</h3><p>不能保证不溢出，只能保证SOF出现的几率小</p><h3 id="3分配的栈内存越大越好么？"><a href="#3分配的栈内存越大越好么？" class="headerlink" title="3分配的栈内存越大越好么？"></a>3分配的栈内存越大越好么？</h3><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h3 id="4垃圾回收是否涉及到虚拟机栈？"><a href="#4垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="4垃圾回收是否涉及到虚拟机栈？"></a>4垃圾回收是否涉及到虚拟机栈？</h3><p>不会</p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><h3 id="5方法中定义的局部变量是否线程安全？"><a href="#5方法中定义的局部变量是否线程安全？" class="headerlink" title="5方法中定义的局部变量是否线程安全？"></a>5方法中定义的局部变量是否线程安全？</h3><p>具体问题具体分析</p><ol><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql_04运算符</title>
      <link href="/2022/04/11/Mysql-04%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2022/04/11/Mysql-04%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4_运算符"></a>4_<strong>运算符</strong></h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. <strong>算术运算符</strong></h3><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加</p><p>（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）运算。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/4_1.png" alt="sql"></p><h4 id="1-1．加法与减法运算符"><a href="#1-1．加法与减法运算符" class="headerlink" title="1.1．加法与减法运算符"></a>1.1<strong>．加法与减法运算符</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual; </span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+ </span><br><span class="line">| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 | </span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+ </span><br><span class="line">| 100 | 100  | 100 | 150  | 120  | 135.5  | 64.5 | </span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+ </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>由运算结果可以得出如下结论：</p><blockquote><p>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</p><p>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</p><p>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</p><p>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数</p><p>值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL</p><p>中字符串拼接要使用字符串函数CONCAT()实现）</p></blockquote><h4 id="1-2．乘法与除法运算符"><a href="#1-2．乘法与除法运算符" class="headerlink" title="1.2．乘法与除法运算符"></a>1.2<strong>．乘法与除法运算符</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">100</span>, <span class="number">100</span> <span class="operator">*</span> <span class="number">1</span>, <span class="number">100</span> <span class="operator">*</span> <span class="number">1.0</span>, <span class="number">100</span> <span class="operator">/</span> <span class="number">1.0</span>, <span class="number">100</span> <span class="operator">/</span> <span class="number">2</span>,<span class="number">100</span> <span class="operator">+</span> <span class="number">2</span> <span class="operator">*</span> <span class="number">5</span> <span class="operator">/</span> <span class="number">2</span>,<span class="number">100</span> <span class="operator">/</span><span class="number">3</span>, <span class="number">100</span> DIV <span class="number">0</span></span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">*</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">*</span> <span class="number">1.0</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">/</span> <span class="number">1.0</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">/</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">+</span> <span class="number">2</span> <span class="operator">*</span> <span class="number">5</span> <span class="operator">/</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">/</span><span class="number">3</span>  <span class="operator">|</span> <span class="number">100</span> DIV <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> <span class="number">100.0</span>  <span class="operator">|</span> <span class="number">100.0000</span>  <span class="operator">|</span> <span class="number">50.0000</span> <span class="operator">|</span> <span class="number">105.0000</span> <span class="operator">|</span> <span class="number">33.3333</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#计算出员工的年基本工资</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,salary <span class="operator">*</span> <span class="number">12</span> annual_sal </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>由运算结果可以得出如下结论：</p><blockquote><p>一个数乘以整数1和除以整数1后仍得原数；</p><p>一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</p><p>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</p><p>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</p><p>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</p><p>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。 </p></blockquote><h4 id="1-3．求模（求余）运算符"><a href="#1-3．求模（求余）运算符" class="headerlink" title="1.3．求模（求余）运算符"></a>1.3<strong>．求模（求余）运算符</strong></h4><p> 将t22表中的字段i对3和5进行求模（求余）运算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">12</span> <span class="operator">%</span> <span class="number">3</span>, <span class="number">12</span> MOD <span class="number">5</span> <span class="keyword">FROM</span> dual;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">%</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">12</span> MOD <span class="number">5</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#筛选出employee_id是偶数的员工 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> employee_id MOD <span class="number">2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以看到，100对3求模后的结果为3，对5求模后的结果为0。 </p><h3 id="2比较运算符"><a href="#2比较运算符" class="headerlink" title="2比较运算符"></a>2<strong>比较运算符</strong></h3><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果</p><p>为假则返回0，其他情况则返回NULL。</p><p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/4_2.png" alt="sql" style="zoom: 50%;" /><h4 id="2-1．等号运算符"><a href="#2-1．等号运算符" class="headerlink" title="2.1．等号运算符"></a>2.1<strong>．等号运算符</strong></h4><p>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。</p><p>在使用等号运算符时，遵循如下规则：</p><p>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</p><p>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</p><p>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</p><p>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</p><p>对比：SQL中赋值符号使用 :&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span>, <span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span> <span class="operator">=</span> <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>, (<span class="number">5</span> <span class="operator">+</span> <span class="number">3</span>) <span class="operator">=</span> (<span class="number">2</span> <span class="operator">+</span> <span class="number">6</span>), <span class="string">&#x27;&#x27;</span> <span class="operator">=</span> <span class="keyword">NULL</span> , <span class="keyword">NULL</span> <span class="operator">=</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+-------+-----------+-------------------+-----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">|</span> (<span class="number">5</span> <span class="operator">+</span> <span class="number">3</span>) <span class="operator">=</span> (<span class="number">2</span> <span class="operator">+</span> <span class="number">6</span>) <span class="operator">|</span> <span class="string">&#x27;&#x27;</span> <span class="operator">=</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">=</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+-------+-----------+-------------------+-----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+-------+-----------+-------------------+-----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">2</span>, <span class="number">0</span> <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>, <span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">FROM</span> dual;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询salary<span class="operator">=</span><span class="number">10000</span>，注意在Java中比较是<span class="operator">=</span><span class="operator">=</span> </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">=</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p>2<strong>．安全等于运算符</strong> 安全等于运算符（&lt;&#x3D;&gt;）与等于运算符（&#x3D;）的作用是相似的， 唯一的区别 是‘&lt;&#x3D;&gt;’可</p><p>以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL</p><p>时，其返回值为0，而不为NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">&lt;=&gt;</span> <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span> <span class="operator">&lt;=&gt;</span> <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> <span class="operator">&lt;=&gt;</span> <span class="string">&#x27;a&#x27;</span>, (<span class="number">5</span> <span class="operator">+</span> <span class="number">3</span>) <span class="operator">&lt;=&gt;</span> (<span class="number">2</span> <span class="operator">+</span> <span class="number">6</span>), <span class="string">&#x27;&#x27;</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>,<span class="keyword">NULL</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span> <span class="keyword">FROM</span> dual; </span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+---------+-------------+---------------------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">&lt;=&gt;</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">&lt;=&gt;</span> <span class="number">0</span> <span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">&lt;=&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">|</span> (<span class="number">5</span> <span class="operator">+</span> <span class="number">3</span>) <span class="operator">&lt;=&gt;</span> (<span class="number">2</span> <span class="operator">+</span> <span class="number">6</span>) <span class="operator">|</span> <span class="string">&#x27;&#x27;</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+---------+-------------+---------------------+-------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+---------+-------------+---------------------+-------------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询commission_pct等于<span class="number">0.40</span> </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> commission_pct <span class="operator">=</span> <span class="number">0.40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> commission_pct <span class="operator">&lt;=&gt;</span> <span class="number">0.40</span>;</span><br><span class="line">#如果把<span class="number">0.40</span>改成 <span class="keyword">NULL</span> 呢？</span><br></pre></td></tr></table></figure><p>可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他</p><p>返回结果与等于运算符相同。</p><p>3<strong>．不等于运算符</strong> 不等于运算符（&lt;&gt;和!&#x3D;）用于判断两边的数字、字符串或者表达式的值是否不相等，</p><p>如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，</p><p>或两边都为NULL，则结果为NULL。 SQL语句示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">&lt;&gt;</span> <span class="number">1</span>, <span class="number">1</span> <span class="operator">!=</span> <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span> <span class="operator">!=</span> <span class="string">&#x27;b&#x27;</span>, (<span class="number">3</span><span class="operator">+</span><span class="number">4</span>) <span class="operator">&lt;&gt;</span> (<span class="number">2</span><span class="operator">+</span><span class="number">6</span>), <span class="string">&#x27;a&#x27;</span> <span class="operator">!=</span> <span class="keyword">NULL</span>, <span class="keyword">NULL</span> <span class="operator">&lt;&gt;</span> <span class="keyword">NULL</span>; </span><br><span class="line"> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------------+----------------+-------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">&lt;&gt;</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">2</span> <span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">!=</span> <span class="string">&#x27;b&#x27;</span> <span class="operator">|</span> (<span class="number">3</span><span class="operator">+</span><span class="number">4</span>) <span class="operator">&lt;&gt;</span> (<span class="number">2</span><span class="operator">+</span><span class="number">6</span>) <span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">!=</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">&lt;&gt;</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------------+----------------+-------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+------------+----------------+-------------+--------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>此外，还有非符号类型的运算符：</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/0001.png" alt="sql"></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/0002.png" alt="sql"></p><ol start="4"><li><strong>空运算符</strong> 空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回</li></ol><p>0。 SQL语句示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NULL</span> <span class="keyword">IS</span> <span class="keyword">NULL</span>, ISNULL(<span class="keyword">NULL</span>), ISNULL(<span class="string">&#x27;a&#x27;</span>), <span class="number">1</span> <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+-------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="operator">|</span> ISNULL(<span class="keyword">NULL</span>) <span class="operator">|</span> ISNULL(<span class="string">&#x27;a&#x27;</span>) <span class="operator">|</span> <span class="number">1</span> <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+-------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+-------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询commission_pct等于<span class="keyword">NULL</span>。比较如下的四种写法 </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ISNULL(commission_pct); </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> commission_pct <span class="operator">=</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, manager_id </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>\5. <strong>非空运算符</strong> 非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返</p><p>回0。 SQL语句示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="string">&#x27;a&#x27;</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="number">1</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">1</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询commission_pct不等于<span class="keyword">NULL</span> </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">NOT</span> commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,commission_pct <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">NOT</span> ISNULL(commission_pct);</span><br></pre></td></tr></table></figure><p>\6. <strong>最小值运算符</strong> 语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有</p><p>两个或多个参数的情况下，返回最小值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LEAST (<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>), LEAST(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>), LEAST(<span class="number">1</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> LEAST (<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>) <span class="operator">|</span> LEAST(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>) <span class="operator">|</span> LEAST(<span class="number">1</span>,<span class="keyword">NULL</span>,<span class="number">2</span>) <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> a <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字</p><p>母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p>\7. <strong>最大值运算符</strong> 语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有</p><p>两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> GREATEST(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>), GREATEST(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>), GREATEST(<span class="number">1</span>,<span class="keyword">NULL</span>,<span class="number">2</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> GREATEST(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>) <span class="operator">|</span> GREATEST(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>) <span class="operator">|</span> GREATEST(<span class="number">1</span>,<span class="keyword">NULL</span>,<span class="number">2</span>) <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> c <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，</p><p>返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p>\8. BETWEEN AND<strong>运算符</strong> BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A </p><p>AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">1</span>, <span class="number">10</span> <span class="keyword">BETWEEN</span> <span class="number">11</span> <span class="keyword">AND</span> <span class="number">12</span>, <span class="string">&#x27;b&#x27;</span> <span class="keyword">BETWEEN</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+----------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">10</span> <span class="keyword">BETWEEN</span> <span class="number">11</span> <span class="keyword">AND</span> <span class="number">12</span> <span class="operator">|</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">BETWEEN</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;c&#x27;</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+----------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+----------------------+-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">2500</span> <span class="keyword">AND</span> <span class="number">3500</span>;</span><br></pre></td></tr></table></figure><p>\9. IN<strong>运算符</strong> IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给</p><p>定的值为NULL，或者IN列表中存在NULL，则结果为NULL。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>), <span class="number">1</span> <span class="keyword">IN</span> (<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">NULL</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>), <span class="string">&#x27;a&#x27;</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="keyword">NULL</span>); </span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------------+-------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>) <span class="operator">|</span> <span class="number">1</span> <span class="keyword">IN</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="operator">|</span> <span class="keyword">NULL</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="keyword">NULL</span>) <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------------+-------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+------------+-------------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>\10. NOT IN<strong>运算符</strong> NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一</p><p>个值，则返回1，否则返回0。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>), <span class="number">1</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">2</span>,<span class="number">3</span>); </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>) <span class="operator">|</span> <span class="number">1</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>\11. LIKE<strong>运算符</strong> LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回</p><p>0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。 </p><p>LIKE运算符通常使用如下通配符：</p><blockquote><p>“%”：匹配0个或多个字符。 </p><p>“_”：只能匹配一个字符。 </p></blockquote><p>SQL语句示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span> <span class="keyword">LIKE</span> <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;abc&#x27;</span> <span class="keyword">LIKE</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="keyword">LIKE</span> <span class="string">&#x27;abc&#x27;</span> <span class="operator">|</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">LIKE</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;S%&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_o%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>ESCAPE</p><ul><li>回避特殊符号的：<strong>使用转义符</strong>。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id <span class="keyword">FROM</span> jobs <span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> ‘IT\_<span class="operator">%</span>‘;</span><br></pre></td></tr></table></figure><ul><li>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id </span><br><span class="line"><span class="keyword">FROM</span> jobs </span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> ‘IT$_<span class="operator">%</span>‘ <span class="keyword">escape</span> ‘$‘;</span><br></pre></td></tr></table></figure><p>\12. REGEXP<strong>运算符</strong></p><p>REGEXP运算符用来匹配字符串，语法格式为： expr REGEXP 匹配条件 。如果expr满足匹配条件，返回</p><p>1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。 </p><p>REGEXP运算符在进行匹配时，常用的有下面几种通配符：</p><blockquote><p>（1）‘^’匹配以该字符后面的字符开头的字符串。 </p><p>（2）‘$’匹配以该字符前面的字符结尾的字符串。 </p><p>（3）‘.’匹配任何一个单字符。 </p><p>（4）“[…]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 </p><p>个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。 </p><p>（5）‘<em>’匹配零个或多个在它前面的字符。例如，“x</em>”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字， </p><p>而“*”匹配任何数量的任何字符。 </p></blockquote><p>SQL语句示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;^s&#x27;</span>, <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;t$&#x27;</span>, <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;hk&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;^s&#x27;</span> <span class="operator">|</span> <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;t$&#x27;</span> <span class="operator">|</span> <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;hk&#x27;</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+------------------------+-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;atguigu&#x27;</span> REGEXP <span class="string">&#x27;gu.gu&#x27;</span>, <span class="string">&#x27;atguigu&#x27;</span> REGEXP <span class="string">&#x27;[ab]&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="string">&#x27;atguigu&#x27;</span> REGEXP <span class="string">&#x27;gu.gu&#x27;</span> <span class="operator">|</span> <span class="string">&#x27;atguigu&#x27;</span> REGEXP <span class="string">&#x27;[ab]&#x27;</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. <strong>逻辑运算符</strong></h3><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。 </p><p>MySQL中支持4种逻辑运算符如下：</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/0003.png" alt="sql"></p><p>1<strong>．逻辑非运算符</strong> 逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；</p><p>当给定的值为NULL时，返回NULL。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOT</span> <span class="number">1</span>, <span class="keyword">NOT</span> <span class="number">0</span>, <span class="keyword">NOT</span>(<span class="number">1</span><span class="operator">+</span><span class="number">1</span>), <span class="keyword">NOT</span> <span class="operator">!</span><span class="number">1</span>, <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+----------+--------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NOT</span> <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NOT</span> <span class="number">0</span> <span class="operator">|</span> <span class="keyword">NOT</span>(<span class="number">1</span><span class="operator">+</span><span class="number">1</span>) <span class="operator">|</span> <span class="keyword">NOT</span> <span class="operator">!</span><span class="number">1</span> <span class="operator">|</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+----------+--------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+----------+--------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;IT_PROG&#x27;</span>, <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;SA_REP&#x27;</span>);</span><br></pre></td></tr></table></figure><p>2<strong>．逻辑与运算符</strong> 逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回</p><p>1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">-1</span>, <span class="number">0</span> <span class="keyword">AND</span> <span class="number">1</span>, <span class="number">0</span> <span class="keyword">AND</span> <span class="keyword">NULL</span>, <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">-1</span> <span class="operator">|</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span><span class="number">10000</span> <span class="keyword">AND</span> job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%MAN%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>3<strong>．逻辑或运算符</strong> 逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返</p><p>回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为</p><p>NULL时，返回NULL。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">OR</span> <span class="number">-1</span>, <span class="number">1</span> <span class="keyword">OR</span> <span class="number">0</span>, <span class="number">1</span> <span class="keyword">OR</span> <span class="keyword">NULL</span>, <span class="number">0</span> <span class="operator">||</span> <span class="keyword">NULL</span>, <span class="keyword">NULL</span> <span class="operator">||</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+-----------+-----------+--------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="keyword">OR</span> <span class="number">-1</span> <span class="operator">|</span> <span class="number">1</span> <span class="keyword">OR</span> <span class="number">0</span> <span class="operator">|</span> <span class="number">1</span> <span class="keyword">OR</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">||</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">||</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+-----------+-----------+--------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+-----------+-----------+--------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询基本薪资不在<span class="number">9000</span><span class="number">-12000</span>之间的员工编号和基本薪资 </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">NOT</span> (salary <span class="operator">&gt;=</span> <span class="number">9000</span> <span class="keyword">AND</span> salary <span class="operator">&lt;=</span> <span class="number">12000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&lt;</span><span class="number">9000</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">12000</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">9000</span> <span class="keyword">AND</span> <span class="number">12000</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span> <span class="keyword">OR</span> job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%MAN%&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先</p><p>对AND两边的操作数进行操作，再与OR中的操作数结合。</p></blockquote><p>4<strong>．逻辑异或运算符</strong> 逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果</p><p>两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> XOR <span class="number">-1</span>, <span class="number">1</span> XOR <span class="number">0</span>, <span class="number">0</span> XOR <span class="number">0</span>, <span class="number">1</span> XOR <span class="keyword">NULL</span>, <span class="number">1</span> XOR <span class="number">1</span> XOR <span class="number">1</span>, <span class="number">0</span> XOR <span class="number">0</span> XOR <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+---------+------------+---------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> XOR <span class="number">-1</span> <span class="operator">|</span> <span class="number">1</span> XOR <span class="number">0</span> <span class="operator">|</span> <span class="number">0</span> XOR <span class="number">0</span> <span class="operator">|</span> <span class="number">1</span> XOR <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">1</span> XOR <span class="number">1</span> XOR <span class="number">1</span> <span class="operator">|</span> <span class="number">0</span> XOR <span class="number">0</span> XOR <span class="number">0</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+---------+------------+---------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+---------+---------+------------+---------------+---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name,department_id,salary</span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> department_id <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>) XOR salary <span class="operator">&gt;</span> <span class="number">8000</span>;</span><br></pre></td></tr></table></figure><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. <strong>位运算符</strong></h3><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，</p><p>最后将计算结果从二进制变回十进制数。</p><p>MySQL支持的位运算符如下：</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/0004.png" alt="sql"></p><p>1<strong>．按位与运算符</strong> 按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二</p><p>进制位的数值都为1时，则该位返回1，否则返回0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">&amp;</span> <span class="number">10</span>, <span class="number">20</span> <span class="operator">&amp;</span> <span class="number">30</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">&amp;</span> <span class="number">10</span> <span class="operator">|</span> <span class="number">20</span> <span class="operator">&amp;</span> <span class="number">30</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>1的二进制数为0001，10的二进制数为1010，所以1 &amp; 10的结果为0000，对应的十进制数为0。20的二进制</p><p>数为10100，30的二进制数为11110，所以20 &amp; 30的结果为10100，对应的十进制数为20。</p><ol start="2"><li><strong>按位或运算符</strong> 按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的</li></ol><p>二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">10</span>, <span class="number">20</span> <span class="operator">|</span> <span class="number">30</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span>  <span class="operator">|</span> <span class="number">30</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进</p><p>制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。3. <strong>按位异或运算符</strong> 按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值</p><p>对应的二进制位的数值不同时，则该位返回1，否则返回0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">^</span> <span class="number">10</span>, <span class="number">20</span> <span class="operator">^</span> <span class="number">30</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">^</span> <span class="number">10</span> <span class="operator">|</span> <span class="number">20</span> <span class="operator">^</span> <span class="number">30</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span>  <span class="operator">|</span> <span class="number">10</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进</p><p>制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。</p><p>再举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">12</span> <span class="operator">&amp;</span> <span class="number">5</span>, <span class="number">12</span> <span class="operator">|</span> <span class="number">5</span>,<span class="number">12</span> <span class="operator">^</span> <span class="number">5</span> <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">&amp;</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">^</span> <span class="number">5</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">13</span>  <span class="operator">|</span> <span class="number">9</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/0005.png" alt="sql" style="zoom:50%;" /><ol start="4"><li><strong>按位取反运算符</strong> 按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变</li></ol><p>为1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">10</span> <span class="operator">&amp;</span> <span class="operator">~</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">&amp;</span> <span class="operator">~</span><span class="number">1</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以10 &amp; ~1，首先，对数字1进</p><p>行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。 </p><ol start="5"><li><strong>按位右移运算符</strong> 按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的</li></ol><p>位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">&gt;&gt;</span> <span class="number">2</span>, <span class="number">4</span> <span class="operator">&gt;&gt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">&gt;&gt;</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">4</span> <span class="operator">&gt;&gt;</span> <span class="number">2</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2</p><p>位为0000 0001，对应的十进制数为1。 </p><ol start="6"><li><strong>按位左移运算符</strong> 按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的</li></ol><p>位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">2</span>, <span class="number">4</span> <span class="operator">&lt;&lt;</span> <span class="number">2</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">4</span> <span class="operator">&lt;&lt;</span> <span class="number">2</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">16</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移</p><p>两位为0001 0000，对应的十进制数为16。 </p><h3 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. <strong>运算符的优先级</strong></h3><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/0006.png" alt="sql" style="zoom:50%;" /><p>数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使</p><p>用“()”括起来的表达式的优先级最高。</p><h3 id="拓展：使用正则表达式查询"><a href="#拓展：使用正则表达式查询" class="headerlink" title="拓展：使用正则表达式查询"></a><strong>拓展：使用正则表达式查询</strong></h3><p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合</p><p>要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户</p><p>输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常</p><p>复杂的查询。</p><p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配</p><p>列表。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/04/0007.png" alt="sql" style="zoom:50%;" /><p>\1. <strong>查询以特定字符或字符串开头的记录</strong> 字符‘^’匹配以特定字符或者字符串开头的文本。</p><p>在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;^b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>\2. <strong>查询以特定字符或字符串结尾的记录</strong> 字符‘$’匹配以特定字符或者字符串结尾的文本。</p><p>在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;y$&#x27;</span>;</span><br></pre></td></tr></table></figure><p>\3. <strong>用符号</strong>“.”<strong>来替代字符串中的任意一个字符</strong> 字符‘.’匹配任意一个字符。 在fruits表中，查询f_name字段值</p><p>包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;a.g&#x27;</span>;</span><br></pre></td></tr></table></figure><p>\4. <strong>使用</strong>“<em>“<strong>和</strong>“+”<strong>来匹配多个字符</strong> 星号‘</em>’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至</p><p>少一次。</p><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;^ba*&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;^ba+&#x27;</span>;</span><br></pre></td></tr></table></figure><p>\5. <strong>匹配指定字符串</strong> 正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个</p><p>字符串，多个字符串之间使用分隔符‘|’隔开。</p><p>在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;on&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;on|ap&#x27;</span>;</span><br></pre></td></tr></table></figure><p>之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中</p><p>间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中</p><p>出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。</p><p>在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name <span class="keyword">like</span> <span class="string">&#x27;on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span>(<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>\6. <strong>匹配指定字符中的任意一个</strong> 方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的</p><p>文本。</p><p>在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;[ot]&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> s_id REGEXP <span class="string">&#x27;[456]&#x27;</span>;</span><br></pre></td></tr></table></figure><p>\7. <strong>匹配指定字符以外的字符</strong> “[^字符集合]” 匹配不在指定集合中的任何字符。</p><p>在fruits表中，查询f_id字段中包含字母a<del>e和数字1</del>2以外字符的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_id REGEXP <span class="string">&#x27;[^a-e1-2]&#x27;</span>;</span><br></pre></td></tr></table></figure><p>\8. <strong>使用</strong>{n,}<strong>或者</strong>{n,m}<strong>来指定字符串连续出现的次数</strong> “字符串{n,}”表示至少匹配n次前面的字符；“字符串</p><p>{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以</p><p>大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。</p><p>在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;x&#123;2,&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> fruits <span class="keyword">WHERE</span> f_name REGEXP <span class="string">&#x27;ba&#123;1,3&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql_03基本的select语句</title>
      <link href="/2022/04/10/Mysql-03%E5%9F%BA%E6%9C%AC%E7%9A%84select%E8%AF%AD%E5%8F%A5/"/>
      <url>/2022/04/10/Mysql-03%E5%9F%BA%E6%9C%AC%E7%9A%84select%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="3-基本的SELECT语句"><a href="#3-基本的SELECT语句" class="headerlink" title="3._基本的SELECT语句"></a>3._<strong>基本的</strong>SELECT语句</h2><h3 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1. SQL概述"></a>1. SQL<strong>概述</strong></h3><h4 id="1-1-SQL背景知识"><a href="#1-1-SQL背景知识" class="headerlink" title="1.1 SQL背景知识"></a>1.1 SQL<strong>背景知识</strong></h4><ul><li><p>1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十</p><p>年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的</p><p>波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。</p><ul><li><p>45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构</p><p>化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语</p><p>言， SQL 的半衰期可以说是非常长 了。</p></li></ul></li><li><p>不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地</p><p>提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以</p><p>便指导业务决策。</p></li><li><p>SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言， 与数据直 </p><p>接打交道 ，由 IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，</p><p>先后有 SQL-86 ， SQL-89 ， SQL-92 ， SQL-99 等标准。</p><ul><li><p>SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标</p><p>准，我们今天使用的 SQL 语言依然遵循这些标准。</p></li></ul></li><li><p>不同的数据库生产厂商都支持SQL语句，但都有特有内容。</p></li></ul><h4 id="1-2SQL语言排行榜"><a href="#1-2SQL语言排行榜" class="headerlink" title="1.2SQL语言排行榜"></a>1.2SQL<strong>语言排行榜</strong></h4><p>自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。 </p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/0003.png" alt="sql"></p><h4 id="1-3-SQL-分类"><a href="#1-3-SQL-分类" class="headerlink" title="1.3 SQL 分类"></a>1.3 SQL <strong>分类</strong></h4><p>SQL语言在功能上主要分为如下3大类：</p><ul><li><p>DDL<strong>（</strong>Data Definition Languages<strong>、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索</p><p>引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p><ul><li>主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等。</li></ul></li><li><p>DML<strong>（</strong>Data Manipulation Language<strong>、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记</p><p>录，并检查数据完整性。</p><ul><li>主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。</li><li>SELECT<strong>是</strong>SQL<strong>语言的基础，最为重要。</strong></li></ul></li><li><p>DCL<strong>（</strong>Data Control Language<strong>、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和</p><p>安全级别。</p><ul><li>主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。</li></ul></li></ul><blockquote><p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。</p><p>还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语</p><p>言）。</p></blockquote><h3 id="2-SQL语言的规则与规范"><a href="#2-SQL语言的规则与规范" class="headerlink" title="2. SQL语言的规则与规范"></a>2. SQL<strong>语言的规则与规范</strong></h3><h4 id="2-1基本规则"><a href="#2-1基本规则" class="headerlink" title="2.1基本规则"></a>2.1基本规则</h4><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 ; 或 \g 或 \G 结束</li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li><li>列的别名，尽量使用双引号（” “），而且不建议省略as</li></ul></li></ul><h4 id="2-2-SQL大小写规范-（建议遵守）"><a href="#2-2-SQL大小写规范-（建议遵守）" class="headerlink" title="2.2 SQL大小写规范 （建议遵守）"></a>2.2 SQL<strong>大小写规范 （建议遵守）</strong></h4><ul><li><p>MySQL <strong>在</strong> Windows <strong>环境下是大小写不敏感的</strong></p></li><li><p>MySQL <strong>在</strong> Linux <strong>环境下是大小写敏感的</strong></p><ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li></ul></li><li><p><strong>推荐采用统一的书写规范：</strong></p><ul><li><p>数据库名、表名、表别名、字段名、字段别名等都小写</p></li><li><p>SQL 关键字、函数名、绑定变量等都大写</p></li></ul></li></ul><h4 id="2-3-注-释"><a href="#2-3-注-释" class="headerlink" title="2.3 注 释"></a>2.3 <strong>注 释</strong></h4><p>可以使用如下格式的注释结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：#注释文字(MySQL特有的方式) </span><br><span class="line">单行注释：<span class="comment">-- 注释文字(--后面必须包含一个空格。) </span></span><br><span class="line">多行注释：<span class="comment">/* 注释文字 */</span></span><br></pre></td></tr></table></figure><h4 id="2-4-命名规则（暂时了解）"><a href="#2-4-命名规则（暂时了解）" class="headerlink" title="2.4 命名规则（暂时了解）"></a>2.4 <strong>命名规则（暂时了解）</strong></h4><ul><li><p>数据库、表名不得超过30个字符，变量名限制为29个</p></li><li><p>必须只能包含 A–Z, a–z, 0–9, _共63个字符</p></li><li><p>数据库名、表名、字段名等对象名中间不要包含空格</p></li><li><p>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</p></li><li><p>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使</p></li></ul><p>​       用&#96;（着重号）引起来</p><ul><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据</li></ul><p>​        类型在一个表里是整数，那在另一个表里可就别变成字符型了</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#以下两句是一样的，不区分大小写 </span><br><span class="line">show databases; </span><br><span class="line">SHOW DATABASES; </span><br><span class="line">#创建表格 </span><br><span class="line">#create table student info(...); #表名错误，因为表名有空格</span><br><span class="line">create table student_info(...);</span><br><span class="line">#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了</span><br><span class="line">CREATE TABLE `order`(</span><br><span class="line">  id INT,</span><br><span class="line">  lname VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">select id as &quot;编号&quot;, `name` as &quot;姓名&quot; from t_stu; #起别名时，as都可以省略 </span><br><span class="line">select id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略&quot;&quot; </span><br><span class="line">select id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略&quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="2-5-数据导入指令"><a href="#2-5-数据导入指令" class="headerlink" title="2.5 数据导入指令"></a>2.5 <strong>数据导入指令</strong></h4><p>在命令行客户端登录mysql，使用source指令导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">source</span> d:\mysqldb.sql</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc employees;</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field          | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| employee_id    | int(6)      | NO   | PRI | 0       |       | </span><br><span class="line">| first_name     | varchar(20) | YES  |     | NULL    |       | </span><br><span class="line">| last_name      | varchar(25) | NO   |     | NULL    |       | </span><br><span class="line">| email          | varchar(25) | NO   | UNI | NULL    |       | </span><br><span class="line">| phone_number   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| hire_date      | date        | NO   |     | NULL    |       | </span><br><span class="line">| job_id         | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| salary         | double(8,2) | YES  |     | NULL    |       | </span><br><span class="line">| commission_pct | double(2,2) | YES  |     | NULL    |       | </span><br><span class="line">| manager_id     | int(6)      | YES  | MUL | NULL    |       | </span><br><span class="line">| department_id  | int(4)      | YES  | MUL | NULL    |       |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="3-基本的SELECT语句-1"><a href="#3-基本的SELECT语句-1" class="headerlink" title="3. 基本的SELECT语句"></a>3. <strong>基本的</strong>SELECT<strong>语句</strong></h3><h4 id="3-0-SELECT…"><a href="#3-0-SELECT…" class="headerlink" title="3.0 SELECT…"></a>3.0 SELECT…</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1; #没有任何子句 </span><br><span class="line">SELECT 9/2; #没有任何子句</span><br></pre></td></tr></table></figure><h4 id="3-1-SELECT-…-FROM"><a href="#3-1-SELECT-…-FROM" class="headerlink" title="3.1 SELECT … FROM"></a>3.1 SELECT … FROM</h4><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 标识选择哪些列 </span><br><span class="line">FROM 标识从哪个表中选择</span><br></pre></td></tr></table></figure><ul><li>选择全部列：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM departments;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/0001.png" alt="sql"></p><blockquote><p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节</p><p>省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通</p><p>配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p><p>在生产环境下，不推荐你直接使用 SELECT * 进行查询。</p></blockquote><ul><li>选择特定的列：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id, location_id </span><br><span class="line">FROM departments;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/0002.png" alt="sql"></p><blockquote><p>MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人</p><p>员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代</p><p>码更容易阅读和维护。</p></blockquote><h4 id="3-2-列的别名"><a href="#3-2-列的别名" class="headerlink" title="3.2 列的别名"></a>3.2 <strong>列的别名</strong></h4><ul><li><p>重命名一个列</p></li><li><p>便于计算</p></li><li><p>紧跟列名，也可以<strong>在列名和别名之间加入关键字</strong>AS<strong>，别名使用双引号</strong>，以便在别名中包含空格或特</p></li><li><p>殊的字符并区分大小写。</p></li><li><p>AS 可以省略</p></li><li><p>建议别名简短，见名知意</p></li></ul><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name AS name, commission_pct comm </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/3_1.png" alt="sql"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="operator">*</span><span class="number">12</span> &quot;Annual Salary&quot; </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/3_2.png" alt="sql"></p><h4 id="3-3-去除重复行"><a href="#3-3-去除重复行" class="headerlink" title="3.3 去除重复行"></a>3.3 <strong>去除重复行</strong></h4><p>默认情况下，查询会返回全部行，包括重复行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/3_3.png" alt="sql"></p><p><strong>在</strong>SELECT<strong>语句中使用关键字</strong>DISTINCT<strong>去除重复行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/3_4.png" alt="sql"></p><p>针对于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>这里有两点需要注意：</p><ol><li>DISTINCT 需要放到所有列名的前面，如果写成 SELECT salary, DISTINCT department_id</li></ol><p>FROM employees 会报错。</p><ol start="2"><li>DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部</li></ol><p>门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需</p><p>要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。</p><h4 id="3-4-空值参与运算"><a href="#3-4-空值参与运算" class="headerlink" title="3.4 空值参与运算"></a>3.4 <strong>空值参与运算</strong></h4><ul><li>所有运算符或列值遇到null值，运算的结果都为null</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,salary,commission_pct, <span class="number">12</span> <span class="operator">*</span> salary <span class="operator">*</span> (<span class="number">1</span> <span class="operator">+</span> commission_pct) &quot;annual_sal&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长</p><p>度是空。而且，在 MySQL 里面，空值是占用空间的。</p><h4 id="3-5-着重号"><a href="#3-5-着重号" class="headerlink" title="3.5 着重号"></a>3.5 <strong>着重号</strong></h4><ul><li>错误的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">ORDER</span>;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that</span><br><span class="line">corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;ORDER&#x27;</span> <span class="keyword">at</span></span><br><span class="line">line <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>正确的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM `ORDER`;</span><br><span class="line">+----------+------------+</span><br><span class="line">| order_id | order_name |</span><br><span class="line">+----------+------------+</span><br><span class="line">| 1        | shkstart   | </span><br><span class="line">| 2        | tomcat     | </span><br><span class="line">| 3        | dubbo      |</span><br><span class="line">+----------+------------+</span><br><span class="line">3 rows in set (0.00 sec) </span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM `order`; </span><br><span class="line">+----------+------------+</span><br><span class="line">| order_id | order_name |</span><br><span class="line">+----------+------------+</span><br><span class="line">| 1        | shkstart   | </span><br><span class="line">| 2        | tomcat     | </span><br><span class="line">| 3        | dubbo      | </span><br><span class="line">+----------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line">北京宏福校区：010-56253825 深</span><br></pre></td></tr></table></figure><ul><li>结论</li></ul><p>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在</p><p>SQL语句中使用一对&#96;&#96;（着重号）引起来。</p><h4 id="3-6-5、查询常数"><a href="#3-6-5、查询常数" class="headerlink" title="3.6 5、查询常数"></a>3.6 5<strong>、查询常数</strong></h4><p>SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的</p><p>取值是我们指定的，而不是从数据表中动态取出的。</p><p>你可能会问为什么我们还要对常数进行查询呢？</p><p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个</p><p>固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p><p>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个</p><p>字段固定值为“尚硅谷”，可以这样写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;尚硅谷&#x27;</span> <span class="keyword">as</span> corporation, last_name <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h3 id="4-显示表结构"><a href="#4-显示表结构" class="headerlink" title="4. 显示表结构"></a>4. <strong>显示表结构</strong></h3><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> employees; 或</span><br><span class="line"><span class="keyword">DESC</span> employees;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> employees; </span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field          <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> employee_id <span class="operator">|</span> <span class="type">int</span>(<span class="number">6</span>)  <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> PRI <span class="operator">|</span> <span class="number">0</span>  <span class="operator">|</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> first_name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> last_name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">25</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> email  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">25</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> UNI <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> phone_number  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> hire_date  <span class="operator">|</span> <span class="type">date</span> <span class="operator">|</span> <span class="keyword">NO</span>  <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> job_id  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">10</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> salary   <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> commission_pct <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">2</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> manager_id  <span class="operator">|</span> <span class="type">int</span>(<span class="number">6</span>)  <span class="operator">|</span> YES  <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">|</span> department_id  <span class="operator">|</span> <span class="type">int</span>(<span class="number">4</span>) <span class="operator">|</span> YES <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>其中，各个字段的含义分别解释如下：</p><ul><li><p>Field：表示字段名称。</p></li><li><p>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</p></li><li><p>Null：表示该列是否可以存储NULL值。</p></li><li><p>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一</p></li><li><p>部分；MUL表示在列中某个给定值允许出现多次。</p></li><li><p>Default：表示该列是否有默认值，如果有，那么值是多少。</p></li><li><p>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</p></li></ul><h3 id="5-过滤数据"><a href="#5-过滤数据" class="headerlink" title="5. 过滤数据"></a>5. <strong>过滤数据</strong></h3><ul><li>背景：</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/3_5.png" alt="sql"></p><ul><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span> </span><br><span class="line"><span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 过滤条件</span><br></pre></td></tr></table></figure><ul><li>使用WHERE 子句，将不满足条件的行过滤掉</li><li>WHERE<strong>子句紧随</strong> FROM<strong>子句</strong></li></ul><p>举例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/03/3_6.png" alt="sql"></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql_02环境搭建</title>
      <link href="/2022/04/10/Mysql-02%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/04/10/Mysql-02%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第02章-MySQL环境搭建"><a href="#第02章-MySQL环境搭建" class="headerlink" title="第02章_MySQL环境搭建"></a><strong>第</strong>02<strong>章</strong>_MySQL<strong>环境搭建</strong></h1><h2 id="1-MySQL的卸载"><a href="#1-MySQL的卸载" class="headerlink" title="1. MySQL的卸载"></a>1. MySQL<strong>的卸载</strong></h2><p><strong>步骤</strong>1<strong>：停止</strong>MySQL<strong>服务</strong></p><p>在卸载之前，先停止MySQL8.0的服务。按键盘上的“Ctrl + Alt + Delete”组合键，打开“任务管理器”对话</p><p>框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停 </p><p>止”选项停止MySQL8.0的服务，如图所示。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0001.png" alt="sql" style="zoom: 50%;" /><p><strong>步骤</strong>2<strong>：软件的卸载</strong></p><p><strong>方式</strong>1<strong>：通过控制面板方式</strong></p><p>卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中</p><p>找到MySQL8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着</p><p>删除。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0002.png" alt="sql" style="zoom: 50%;" /><p><strong>方式</strong>2<strong>：通过</strong>360<strong>或电脑管家等软件卸载</strong></p><p>略</p><p><strong>方式</strong>3<strong>：通过安装包提供的卸载功能卸载</strong></p><p>你也可以通过安装向导程序进行MySQL8.0服务器程序的卸载。</p><p>① 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已</p><p>安装的MySQL服务器程序。</p><p>② 选择要卸载的MySQL服务器程序，单击“Remove”（移除），即可进行卸载。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0003.png" alt="sql" style="zoom: 50%;" /><p>③ 单击“Next”（下一步）按钮，确认卸载。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0004.png" alt="sql" style="zoom:50%;" /><p>④ 弹出是否同时移除数据目录选择窗口。如果想要同时删除MySQL服务器中的数据，则勾选“Remove the </p><p>data directory”，如图所示。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0005.png" alt="sql" style="zoom:50%;" /><p>⑤ 执行卸载。单击“Execute”（执行）按钮进行卸载。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0006.png" alt="sql" style="zoom:50%;" /><p>⑥ 完成卸载。单击“Finish”（完成）按钮即可。如果想要同时卸载MySQL8.0的安装向导程序，勾选“Yes， </p><p>Uninstall MySQL Installer”即可，如图所示。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0007.png" alt="sql" style="zoom:50%;" /><p><strong>步骤</strong>3<strong>：残余文件的清理</strong></p><p>如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。</p><p>（1）服务目录：mysql服务的安装目录</p><p>（2）数据目录：默认在C:\ProgramData\MySQL</p><p>如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可</p><blockquote><p>注意：请在卸载前做好数据备份</p><p>在操作完以后，需要重启计算机，然后进行安装即可。<strong>如果仍然安装失败，需要继续操作如下步</strong></p><p><strong>骤</strong>4<strong>。</strong> </p></blockquote><p><strong>步骤</strong>4<strong>：清理注册表（选做）</strong></p><p>如果前几步做了，再次安装还是失败，那么可以清理注册表。</p><p>如何打开注册表编辑器：在系统的搜索框中输入 regedit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL服务目录 删除HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL服务删除</span><br></pre></td></tr></table></figure><blockquote><p>注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类</p></blockquote><p><strong>步骤</strong>5<strong>：删除环境变量配置</strong></p><p>找到path环境变量，将其中关于mysql的环境变量删除，<strong>切记不要全部删除。</strong></p><p>例如：删除 D:\develop_tools\mysql\MySQLServer8.0.26\bin; 这个部分</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0008.png" alt="sql" style="zoom:50%;" /><h2 id="2-MySQL的下载、安装、配置"><a href="#2-MySQL的下载、安装、配置" class="headerlink" title="2. MySQL的下载、安装、配置"></a>2. MySQL<strong>的下载、安装、配置</strong></h2><h3 id="2-1mysql四大版本"><a href="#2-1mysql四大版本" class="headerlink" title="2.1mysql四大版本"></a>2.1mysql四大版本</h3><blockquote><p>MySQL Community Server <strong>社区版本</strong>，开源免费，自由下载，但不提供官方技术支持，适用于</p><p>大多数普通用户。</p><p>MySQL Enterprise Edition <strong>企业版本</strong>，需付费，不能在线下载，可以试用30天。提供了更多的</p><p>功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。</p><p>MySQL Cluster <strong>集群版</strong>，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个</p><p>Server。需要在社区版或企业版的基础上使用。</p><p>MySQL Cluster CGE <strong>高级集群版</strong>，需付费。</p></blockquote><ul><li><p>目前最新版本为 8.0.27 ，发布时间 2021年10月 。此前，8.0.0 在 2016.9.12日就发布了。</p></li><li><p>本课程中使用 8.0.26版本 。</p></li></ul><p>此外，官方还提供了 MySQL Workbench （GUITOOL）一款专为MySQL设计的 图形界面管理工具 。 </p><p>MySQLWorkbench又分为两个版本，分别是 社区版 （MySQL Workbench OSS）、 商用版 （MySQL </p><p>WorkbenchSE）。</p><h3 id="2-2-软件的下载"><a href="#2-2-软件的下载" class="headerlink" title="2.2 软件的下载"></a>2.2 <strong>软件的下载</strong></h3><p>\1. <strong>下载地址</strong></p><p>官网：<a href="https://www.mysql.com/">https://www.mysql.com</a> </p><p>\2. <strong>打开官网，点击</strong>DOWNLOADS</p><p>然后，点击 MySQL Community(GPL) Downloads</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0009.png" alt="sql" style="zoom:50%;" /><p>\3. <strong>点击</strong> MySQL Community Server</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0010.png" alt="sql" style="zoom:50%;" /><p>\4. <strong>在</strong>General Availability(GA) Releases<strong>中选择适合的版本</strong></p><p>Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文</p><p>件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版</p><p>使用起来要简单，不再需要其他工具启动就可以运行MySQL。</p><ul><li>这里在Windows 系统下推荐下载 MSI安装程序 ；点击 Go to Download Page 进行下载即可</li></ul><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0011.png" alt="sql" style="zoom:50%;" /><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0012.png" alt="sql" style="zoom:50%;" /><ul><li><p>Windows下的MySQL8.0安装有两种安装程序</p><ul><li><p>mysql-installer-web-community-8.0.26.0.msi 下载程序大小：2.4M；安装时需要联网安</p><p>装组件。</p></li><li><p>mysql-installer-community-8.0.26.0.msi 下载程序大小：450.7M；安装时离线安装即</p><p>可。<strong>推荐。</strong></p></li></ul></li><li><p>如果安装MySQL5.7版本的话，选择 Archives ，接着选择MySQL5.7的相应版本即可。这里下载最近</p><p>期的MySQL5.7.34版本。</p></li></ul><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0013.png" alt="sql" style="zoom:50%;" /><h3 id="2-3-MySQL8-0-版本的安装"><a href="#2-3-MySQL8-0-版本的安装" class="headerlink" title="2.3 MySQL8.0 版本的安装"></a>2.3 MySQL8.0 <strong>版本的安装</strong></h3><p>MySQL下载完成后，找到下载文件，双击进行安装，具体操作步骤如下。</p><p>步骤1：双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。</p><p>步骤2：打开“Choosing a Setup Type”（选择安装类型）窗口，在其中列出了5种安装类型，分别是</p><p>Developer Default（默认安装类型）、Server only（仅作为服务器）、Client only（仅作为客户端）、</p><p>Full（完全安装）、Custom（自定义安装）。这里选择“Custom（自定义安装）”类型按钮，单击“Next(下</p><p>一步)”按钮。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0014.png" alt="sql" style="zoom:50%;" /><p>步骤3：打开“Select Products” （选择产品）窗口，可以定制需要安装的产品清单。例如，选择“MySQL </p><p>Server 8.0.26-X64”后，单击“→”添加按钮，即可选择安装MySQL服务器，如图所示。采用通用的方法，可</p><p>以添加其他你需要安装的产品。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0015.png" alt="sql" style="zoom:50%;" /><p>此时如果直接“Next”（下一步），则产品的安装路径是默认的。如果想要自定义安装目录，则可以选中</p><p>对应的产品，然后在下面会出现“Advanced Options”（高级选项）的超链接。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0016.png" alt="sql" style="zoom:50%;" /><p>单击“AdvancedOptions”（高级选项）则会弹出安装目录的选择窗口，如图所示，此时你可以分别设置<br>MySQL的服务程序安装目录和数据存储目录。如果不设置，默认分别在C盘的ProgramFiles目录和<br>ProgramData目录（这是一个隐藏目录）。如果自定义安装目录，请避免“中文”目录。另外，建议服务目录和数据目录分开存放。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0017.png" alt="sql" style="zoom:50%;" /><p>步骤4：在上一步选择好要安装的产品之后，单击“Next”（下一步）进入确认窗口，如图所示。单击“Execute”（执行）按钮开始安装。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0018.png" alt="sql" style="zoom:50%;" /><p>步骤5：安装完成后在“Status”（状态）列表下将显示“Complete”（安装完成），如图所示。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0019.png" alt="sql" style="zoom:50%;" /><h3 id="2-4配置MySQL8-0"><a href="#2-4配置MySQL8-0" class="headerlink" title="2.4配置MySQL8.0"></a>2.4配置MySQL8.0</h3><p>MySQL安装之后，需要对服务器进行配置。具体的配置步骤如下。<br>步骤1：在上一个小节的最后一步，单击“Next”（下一步）按钮，就可以进入产品配置窗口。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0020.png" alt="sql" style="zoom:50%;" /><p>步骤2：单击“Next”（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认端口号3306。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0021.png" alt="sql" style="zoom:50%;" /><p>其中，“ConfigType”选项用于设置服务器的类型。单击该选项右侧的下三角按钮，即可查看3个选项，如图所示。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0022.png" alt="sql" style="zoom:50%;" /><p>DevelopmentMachine（开发机器）:该选项代表典型个人用桌面工作站。此时机器上需要运行多个应用程序，那么MySQL服务器将占用最少的系统资源</p><ul><li>ServerMachine（服务器）:该选项代表服务器，MySQL服务器可以同其他服务器应用程序一起运行，例如Web服务器等。MySQL服务器配置成适当比例的系统资源。</li><li>DedicatedMachine（专用服务器）：该选项代表只运行MySQL服务的服务器。MySQL服务器配置成使用所有可用系统资源。</li></ul><p>步骤3：单击“Next”（下一步）按钮，打开设置授权方式窗口。其中，上面的选项是MySQL8.0提供的新的授权方式，采用SHA256基础的密码加密方法；下面的选项是传统授权方法（保留5.x版本兼容性）。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0023.png" alt="sql" style="zoom:50%;" /><p>步骤4：单击“Next”（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“AddUser”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台&#x2F;哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在MySQL高级特性篇中讲解。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0024.png" alt="sql" style="zoom:50%;" /><p>步骤5：单击“Next”（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在Windows 服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为<br>“MySQL80”。如果希望开机自启动服务，也可以勾选“StarttheMySQLServeratSystemStartup”选项（推荐）。</p><p>下面是选择以什么方式运行服务？可以选择“StandardSystemAccount”(标准系统用户)或者“CustomUser”(自定义用户)中的一个。这里推荐前者。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0025.png" alt="sql" style="zoom:50%;" /><p>步骤6：单击“Next”（下一步）按钮，打开确认设置服务器窗口，单击“Execute”（执行）按钮</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0026.png" alt="sql" style="zoom:50%;" /><p>步骤7：完成配置，如图所示。单击“Finish”（完成）按钮，即可完成服务器的配置</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0027.png" alt="sql" style="zoom:50%;" /><p>步骤8：如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择“Next”（下一步），直接完成整个安装和配置过程。</p><h3 id="2-5配置MySQL8-0环境变量"><a href="#2-5配置MySQL8-0环境变量" class="headerlink" title="2.5配置MySQL8.0环境变量"></a>2.5配置MySQL8.0环境变量</h3><p>如果不配置MySQL环境变量，就不能在命令行直接输入MySQL登录命令。下面说如何配置MySQL的环境变量：<br>步骤1：在桌面上右击【此电脑】图标，在弹出的快捷菜单中选择【属性】菜单命令。</p><p>步骤2：打开【系统】窗口，单击【高级系统设置】链接。</p><p>步骤3：打开【系统属性】对话框，选择【高级】选项卡，然后单击【环境变量】按钮。</p><p>步骤4：打开【环境变量】对话框，在系统变量列表中选择path变量。</p><p>步骤5：单击【编辑】按钮，在【编辑环境变量】对话框中，将MySQL应用程序的bin目录（C:\Program Files\MySQL\MySQLServer8.0\bin）添加到变量值中，用分号将其与其他路径分隔开。</p><p>步骤6：添加完成之后，单击【确定】按钮，这样就完成了配置path变量的操作，然后就可以直接输入MySQL命令来登录数据库了。</p><h3 id="2-6MySQL5-7版本的安装、配置"><a href="#2-6MySQL5-7版本的安装、配置" class="headerlink" title="2.6MySQL5.7版本的安装、配置"></a>2.6MySQL5.7版本的安装、配置</h3><p>此版本的安装过程与上述过程除了版本号不同之外，其它环节都是相同的。所以这里省略了MySQL5.7.34 版本的安装截图。</p><ul><li>配置</li></ul><p>配置环节与MySQL8.0版本确有细微不同。大部分情况下直接选择“Next”即可，不影响整理使用。这里配置MySQL5.7时，重点强调：与前面安装好的MySQL8.0不能使用相同的端口号。</p><h2 id="3-MySQL的登录"><a href="#3-MySQL的登录" class="headerlink" title="3.MySQL的登录"></a>3.MySQL的登录</h2><h3 id="3-1服务的启动与停止"><a href="#3-1服务的启动与停止" class="headerlink" title="3.1服务的启动与停止"></a>3.1服务的启动与停止</h3><p>MySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。<br>在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也自动启动、停止。</p><h4 id="方式1：使用图形界面工具"><a href="#方式1：使用图形界面工具" class="headerlink" title="方式1：使用图形界面工具"></a>方式1：使用图形界面工具</h4><ul><li>步骤1：打开windows服务</li></ul><p>方式1：计算机（点击鼠标右键）→管理（点击）→服务和应用程序（点击）→服务（点击）<br>方式2：控制面板（点击）→系统和安全（点击）→管理工具（点击）→服务（点击）</p><p>方式3：任务栏（点击鼠标右键）→启动任务管理器（点击）→服务（点击）<br>方式4：单击【开始】菜单，在搜索框中输入“services.msc”，按Enter键确认</p><ul><li>步骤2：找到MySQL80（点击鼠标右键）→启动或停止（点击）</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0028.png" alt="sql"></p><h4 id="方式2：使用命令行工具"><a href="#方式2：使用命令行工具" class="headerlink" title="方式2：使用命令行工具"></a>方式2：使用命令行工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动MySQL服务命令：</span></span><br><span class="line">netstartMySQL服务名</span><br><span class="line"><span class="comment">#停止MySQL服务命令：</span></span><br><span class="line">netstopMySQL服务名</span><br></pre></td></tr></table></figure><p>说明：</p><p>1.start和stop后面的服务名应与之前配置时指定的服务名一致。</p><p>2.如果当你输入命令后，提示“拒绝服务”，请以系统管理员身份打开命令提示符界面重新尝试。</p><h3 id="3-2自带客户端的登录与退出"><a href="#3-2自带客户端的登录与退出" class="headerlink" title="3.2自带客户端的登录与退出"></a>3.2自带客户端的登录与退出</h3><p>当MySQL服务启动完成后，便可以通过客户端来登录MySQL数据库。注意：确认服务是开启的。登录方式1：MySQL自带客户端<br>开始菜单→所有程序→MySQL→MySQL8.0CommandLineClient</p><blockquote><p>说明：仅限于root用户</p></blockquote><p>登录方式2：windows命令行</p><ul><li>格式：</li></ul><p>mysql-h主机名-P端口号-u用户名-p密码</p><ul><li>举例</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql-hlocalhost-P3306-uroot-pabc123 <span class="comment">#这里我设置的root用户的密码是abc123</span></span><br></pre></td></tr></table></figure><p>注意：<br>（1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql-hlocalhost-P3306-uroot-pabc123</span><br></pre></td></tr></table></figure><p>（2）密码建议在下一行输入，保证安全</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql-hlocalhost-P3306-uroot-p </span><br><span class="line">Enterpassword:****</span><br></pre></td></tr></table></figure><p>（3）客户端和服务器在同一台机器上，所以输入localhost或者IP地址127.0.0.1。同时，因为是连接本机：-hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略<br>简写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql-uroot-p </span><br><span class="line">Enterpassword:****</span><br></pre></td></tr></table></figure><p>连接成功后，有关于MySQLServer服务版本的信息，还有第几次连接的id标识。也可以在命令行通过以下方式获取MySQLServer服务版本的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;mysql-V</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;mysql--version</span><br></pre></td></tr></table></figure><p>或登录后，通过以下方式查看当前版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br></pre></td></tr></table></figure><p>退出登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> 或</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><h2 id="4-MySQL演示使用"><a href="#4-MySQL演示使用" class="headerlink" title="4.MySQL演示使用"></a>4.MySQL演示使用</h2><h3 id="4-1MySQL的使用演示"><a href="#4-1MySQL的使用演示" class="headerlink" title="4.1MySQL的使用演示"></a>4.1MySQL的使用演示</h3><p>1、查看所有的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><blockquote><p>“information_schema”是MySQL系统自带的数据库，主要保存MySQL数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件所在的文件夹和系统使用的文件夹，等等<br>“performance_schema”是MySQL系统自带的数据库，可以用来监控MySQL的各类性能指标。<br>“sys”数据库是MySQL系统自带的数据库，主要作用是以一种更容易被理解的方式展示MySQL数据库服务器的各类性能指标，帮助系统管理员和开发人员监控MySQL的技术性能。<br>“mysql”数据库保存了MySQL数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等</p></blockquote><p>为什么Workbench里面我们只能看到“demo”和“sys”这2个数据库呢？<br>这是因为，Workbench是图形化的管理工具，主要面向开发人员，“demo”和“sys”这2个数据库已经够用了。如果有特殊需求，比如，需要监控MySQL数据库各项性能指标、直接操作MySQL数据库系统文件等，可以由DBA通过SQL语句，查看其它的系统数据库。</p><p>2、创建自己的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名;</span><br><span class="line">#创建atguigudb数据库，该名称不能与已经存在的数据库重名。</span><br><span class="line"><span class="keyword">create</span> database atguigudb;</span><br></pre></td></tr></table></figure><p>3、使用自己的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br><span class="line">#使用atguigudb数据库</span><br><span class="line">use atguigudb;</span><br></pre></td></tr></table></figure><p>说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR1046<br>(3D000):Nodatabaseselected”（没有选择数据库）<br>使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另一个数据库操作，那么要重新use。<br>4、查看某个库的所有表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables; #要求前面有use语句</span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">from</span> 数据库名;</span><br></pre></td></tr></table></figure><p>5、创建新的表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>说明：如果是最后一个字段，后面就用加逗号，因为逗号的作用是分割每个字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建学生表</span><br><span class="line">createtablestudent(</span><br><span class="line">  id <span class="type">int</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) #说名字最长不超过<span class="number">20</span>个字符</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>6、查看一个表的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="operator">*</span><span class="keyword">from</span>数据库表名称;</span><br><span class="line">#查看学生表的数据</span><br><span class="line"><span class="keyword">select</span><span class="operator">*</span>fromstudent;</span><br></pre></td></tr></table></figure><p>7、添加一条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名称 <span class="keyword">values</span>(值列表);</span><br><span class="line">#添加两条记录到student表中</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br></pre></td></tr></table></figure><p>报错:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">ERROR1366(HY000):Incorrectstringvalue:<span class="string">&#x27;\xD5\xC5\xC8\xFD&#x27;</span>forcolumn<span class="string">&#x27;name&#x27;</span><span class="keyword">at</span> row1 </span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">ERROR1366(HY000):Incorrectstringvalue:<span class="string">&#x27;\xC0\xEE\xCB\xC4&#x27;</span>forcolumn<span class="string">&#x27;name&#x27;</span><span class="keyword">at</span> row1 </span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure><p>字符集的问题。</p><p>8、查看表的创建信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名称\G </span><br><span class="line"></span><br><span class="line">#查看student表的详细创建信息 </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> student\G</span><br></pre></td></tr></table></figure><p>上面的结果显示student的表格的默认字符集是“latin1”不支持中文。</p><p>9、查看数据库的创建信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名\G </span><br><span class="line">#查看atguigudb数据库的详细创建信息 </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database atguigudb\G</span><br></pre></td></tr></table></figure><p>上面的结果显示atguigudb数据库也不支持中文，字符集默认是latin1。 </p><p>10、删除表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名称;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除学生表 </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure><p>11、删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除atguigudb数据库</span><br><span class="line"><span class="keyword">drop</span> database atguigudb;</span><br></pre></td></tr></table></figure><h3 id="4-2-MySQL的编码设置"><a href="#4-2-MySQL的编码设置" class="headerlink" title="4.2 MySQL的编码设置"></a>4.2 MySQL<strong>的编码设置</strong></h3><p>MySQL5.7<strong>中</strong></p><p><strong>问题再现：命令行操作</strong>sql<strong>乱码问题</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_stu <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1366</span> (HY000): Incorrect string <span class="keyword">value</span>: <span class="string">&#x27;\xD5\xC5\xC8\xFD&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;sname&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>步骤1：查看编码命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_%&#x27;</span>; </span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>步骤2：修改mysql的数据目录下的my.ini配置文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysql] #大概在<span class="number">63</span>行左右，在其下添加 </span><br><span class="line">... </span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span><span class="type">character</span><span class="operator">-</span><span class="keyword">set</span><span class="operator">=</span>utf8 #默认字符集</span><br><span class="line"></span><br><span class="line">[mysqld] # 大概在<span class="number">76</span>行左右，在其下添加 </span><br><span class="line">... </span><br><span class="line"><span class="type">character</span><span class="operator">-</span><span class="keyword">set</span><span class="operator">-</span>server<span class="operator">=</span>utf8</span><br><span class="line"><span class="keyword">collation</span><span class="operator">-</span>server<span class="operator">=</span>utf8_general_ci</span><br></pre></td></tr></table></figure><blockquote><p>注意：建议修改配置文件使用notepad++等高级文本编辑器，使用记事本等软件打开修改后可能会</p><p>导致文件编码修改为“含BOM头”的编码，从而服务重启失败。</p></blockquote><p>步骤3：重启服务</p><p>步骤4：查看编码命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL8.0<strong>中</strong> </p><p>在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3。网站开发人员在数据库设计</p><p>的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0</p><p>开始，数据库的默认编码改为 utf8mb4 ，从而避免了上述的乱码问题。</p><h2 id="5-MySQL图形化管理工具"><a href="#5-MySQL图形化管理工具" class="headerlink" title="5. MySQL图形化管理工具"></a>5. MySQL<strong>图形化管理工具</strong></h2><p>MySQL图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：MySQL </p><p>Workbench、phpMyAdmin、Navicat Preminum、MySQLDumper、SQLyog、dbeaver、MySQL ODBC </p><p>Connector。 </p><p><strong>工具</strong>1. MySQL Workbench </p><p>MySQL官方提供的图形化管理工具MySQL Workbench完全支持MySQL 5.0以上的版本。MySQL Workbench</p><p>分为社区版和商业版，社区版完全免费，而商业版则是按年收费。</p><p>MySQL Workbench 为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库</p><p>管理功能。它包含了用于创建复杂的数据建模ER模型，正向和逆向数据库工程，也可以用于执行通常需</p><p>要花费大量时间的、难以变更和管理的文档任务。</p><p>下载地址：<a href="http://dev.mysql.com/downloads/workbench/%E3%80%82">http://dev.mysql.com/downloads/workbench/。</a></p><p>使用：</p><p>首先，我们点击 Windows 左下角的“开始”按钮，如果你是 Win10 系统，可以直接看到所有程序。接着，</p><p>找到“MySQL”，点开，找到“MySQL Workbench 8.0 CE”。点击打开 Workbench，如下图所示：</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0029.png" alt="sql" style="zoom:50%;" /><p>左下角有个本地连接，点击，录入 Root 的密码，登录本地 MySQL 数据库服务器，如下图所示：</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0030.png" alt="sql" style="zoom:50%;" /><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0031.png" alt="sql" style="zoom:50%;" /><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0032.png" alt="sql" style="zoom:50%;" /><p>这是一个图形化的界面，我来给你介绍下这个界面。</p><ul><li>上方是菜单。左上方是导航栏，这里我们可以看到 MySQL 数据库服务器里面的数据 库，包括数据</li></ul><p>​       表、视图、存储过程和函数；左下方是信息栏，可以显示上方选中的数据 库、数据表等对象的信</p><p>​       息。</p><ul><li>中间上方是工作区，你可以在这里写 SQL 语句，点击上方菜单栏左边的第三个运行按 钮，就可以执</li></ul><p>​        行工作区的 SQL 语句了。</p><ul><li>中间下方是输出区，用来显示 SQL 语句的运行情况，包括什么时间开始运行的、运行的 内容、运行</li></ul><p>​        的输出，以及所花费的时长等信息。</p><p>好了，下面我们就用 Workbench 实际创建一个数据库，并且导入一个 Excel 数据文件， 来生成一个数据</p><p>表。数据表是存储数据的载体，有了数据表以后，我们就能对数据进行操作了。</p><p><strong>工具</strong>2. Navicat </p><p>Navicat MySQL是一个强大的MySQL数据库服务器管理和开发工具。它可以与任何3.21或以上版本的</p><p>MySQL一起工作，支持触发器、存储过程、函数、事件、视图、管理用户等，对于新手来说易学易用。</p><p>其精心设计的图形用户界面（GUI）可以让用户用一种安全简便的方式来快速方便地创建、组织、访问和</p><p>共享信息。Navicat支持中文，有免费版本提供。 下载地址：<a href="http://www.navicat.com/%E3%80%82">http://www.navicat.com/。</a> </p><p><strong>工具</strong>3. SQLyog </p><p>SQLyog 是业界著名的 Webyog 公司出品的一款简洁高效、功能强大的图形化 MySQL 数据库管理工具。</p><p>这款工具是使用C++语言开发的。该工具可以方便地创建数据库、表、视图和索引等，还可以方便地进行</p><p>插入、更新和删除等操作，同时可以方便地进行数据库、数据表的备份和还原。该工具不仅可以通过</p><p>SQL文件进行大量文件的导入和导出，还可以导入和导出XML、HTML和CSV等多种格式的数据。 下载地</p><p>址：<a href="http://www.webyog.com/%EF%BC%8C%E8%AF%BB%E8%80%85%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E4%B8%AD%E6%96%87%E7%89%88%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E3%80%82">http://www.webyog.com/，读者也可以搜索中文版的下载地址。</a></p><h2 id="6-MySQL目录结构与源码"><a href="#6-MySQL目录结构与源码" class="headerlink" title="6. MySQL目录结构与源码"></a>6. MySQL<strong>目录结构与源码</strong></h2><h3 id="6-1-主要目录结构"><a href="#6-1-主要目录结构" class="headerlink" title="6.1 主要目录结构"></a>6.1 <strong>主要目录结构</strong></h3><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0033.png" alt="sql"></p><h3 id="6-2-MySQL-源代码获取"><a href="#6-2-MySQL-源代码获取" class="headerlink" title="6.2 MySQL 源代码获取"></a>6.2 MySQL <strong>源代码获取</strong></h3><p>首先，你要进入 MySQL下载界面。 这里你不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，</p><p>找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点</p><p>击下载。</p><p>接下来，把下载下来的压缩文件解压，我们就得到了 MySQL 的源代码。</p><p>MySQL 是用 C++ 开发而成的，我简单介绍一下源代码的组成。</p><p>mysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码：</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/sql/02/02/0034.png" alt="sql" style="zoom:50%;" /><p>sql 子目录是 MySQL 核心代码；</p><ul><li><p>libmysql 子目录是客户端程序 API； </p></li><li><p>mysql-test 子目录是测试工具；</p></li><li><p>mysys 子目录是操作系统相关函数和辅助函数；</p></li></ul><h2 id="7-常见问题的解决-课外内容"><a href="#7-常见问题的解决-课外内容" class="headerlink" title="7. 常见问题的解决(课外内容)"></a>7. <strong>常见问题的解决</strong>(<strong>课外内容</strong>)</h2><p><strong>问题</strong>1<strong>：</strong>root<strong>用户密码忘记，重置的操作</strong> </p><p>1: 通过任务管理器或者服务管理，关掉mysqld(服务进程) </p><p>2: 通过命令行+特殊参数开启mysqld mysqld – </p><p>defaults-file&#x3D;”D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini” –skip-grant-tables </p><p>3: 此时，mysqld服务进程已经打开。并且不需要权限检查 4: mysql -uroot 无密码登陆服务器。另启动一</p><p>个客户端进行 5: 修改权限表 （1） use mysql; （2）update user set authentication_string&#x3D;password(‘新密</p><p>码’) where user&#x3D;’root’ and Host&#x3D;’localhost’; （3）flush privileges; 6: 通过任务管理器，关掉mysqld服务进</p><p>程。 7: 再次通过服务管理，打开mysql服务。 8: 即可用修改后的新密码登陆。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_03运行时数据区</title>
      <link href="/2022/04/08/JVM-03%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2022/04/08/JVM-03%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3.运行时数据区"></a>3.运行时数据区</h1><h2 id="1运行时数据区概述及线程"><a href="#1运行时数据区概述及线程" class="headerlink" title="1运行时数据区概述及线程"></a>1运行时数据区概述及线程</h2><h3 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h3><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0001.png" alt="jvm"></p><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0002.png" alt="jvm" style="zoom:67%;" /><h3 id="2运行时数据区结构"><a href="#2运行时数据区结构" class="headerlink" title="2运行时数据区结构"></a>2运行时数据区结构</h3><h4 id="1-运行时数据区与内存"><a href="#1-运行时数据区与内存" class="headerlink" title="1.运行时数据区与内存"></a>1.运行时数据区与内存</h4><ol><li>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</li><li>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</li></ol><blockquote><p>图源自阿里巴巴手册</p></blockquote><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0004.jpg" alt="jvm"></p><h4 id="2-线程的内存空间"><a href="#2-线程的内存空间" class="headerlink" title="2.线程的内存空间"></a>2.线程的内存空间</h4><ol><li>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</li><li>灰色的为单独线程私有的，红色的为多个线程共享的。即：<ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0005.png" alt="jvm"></p><h4 id="3-Runtime类"><a href="#3-Runtime类" class="headerlink" title="3.Runtime类"></a>3.Runtime类</h4><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3.线程"></a>3.线程</h3><h4 id="3-1JVM-线程"><a href="#3-1JVM-线程" class="headerlink" title="3.1JVM 线程"></a>3.1JVM 线程</h4><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射<ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><h4 id="3-2JVM-系统线程"><a href="#3-2JVM-系统线程" class="headerlink" title="3.2JVM 系统线程"></a>3.2JVM 系统线程</h4><ul><li>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</li><li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h2 id="2程序计数器-PC寄存器"><a href="#2程序计数器-PC寄存器" class="headerlink" title="2程序计数器(PC寄存器)"></a>2程序计数器(PC寄存器)</h2><h3 id="1PC寄存器介绍"><a href="#1PC寄存器介绍" class="headerlink" title="1PC寄存器介绍"></a>1PC寄存器介绍</h3><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0007.png" alt="jvm"></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><h3 id="2PC寄存器的作用"><a href="#2PC寄存器的作用" class="headerlink" title="2PC寄存器的作用"></a>2PC寄存器的作用</h3><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0008.png" alt="jvm"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">2</span>; size <span class="number">675</span> bytes</span><br><span class="line">  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3</span><br><span class="line">  Compiled from <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.PCRegisterTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">26</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">27</span>            <span class="comment">// abc</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">30.</span>#<span class="number">31</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">32</span>            <span class="comment">// com/atguigu/java/PCRegisterTest</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               args</span><br><span class="line">  #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               i</span><br><span class="line">  #<span class="number">19</span> = Utf8               I</span><br><span class="line">  #<span class="number">20</span> = Utf8               j</span><br><span class="line">  #<span class="number">21</span> = Utf8               k</span><br><span class="line">  #<span class="number">22</span> = Utf8               s</span><br><span class="line">  #<span class="number">23</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">24</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">25</span> = Utf8               PCRegisterTest.java</span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               abc</span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">30</span> = Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               com/atguigu/java/PCRegisterTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        <span class="number">10</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc</span></span><br><span class="line">        <span class="number">12</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">14</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">21</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">24</span>: iload_3</span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">23</span>     <span class="number">2</span>     j   I</span><br><span class="line">           <span class="number">10</span>      <span class="number">19</span>     <span class="number">3</span>     k   I</span><br><span class="line">           <span class="number">14</span>      <span class="number">15</span>     <span class="number">4</span>     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0009.png" alt="jvm"></p><h3 id="3两个面试题"><a href="#3两个面试题" class="headerlink" title="3两个面试题"></a>3两个面试题</h3><ul><li><ol><li><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></li></ol></li></ul><ol><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0010.png" alt="jvm"></p><ul><li><ol start="2"><li><strong>PC寄存器为什么被设定为私有的？</strong></li></ol></li></ul><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><h3 id="4CPU-时间片"><a href="#4CPU-时间片" class="headerlink" title="4CPU 时间片"></a>4CPU 时间片</h3><ol><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0011.png" alt="jvm"></p><h2 id="3本地方法接口"><a href="#3本地方法接口" class="headerlink" title="3本地方法接口"></a>3本地方法接口</h2><h3 id="1本地方法"><a href="#1本地方法" class="headerlink" title="1本地方法"></a>1本地方法</h3><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0012.png" alt="jvm"></p><ol><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</li></ol><h3 id="2举例"><a href="#2举例" class="headerlink" title="2举例"></a>2举例</h3><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">Native2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">Native3</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-为什么要使用-Native-Method？"><a href="#3-为什么要使用-Native-Method？" class="headerlink" title="3.为什么要使用 Native Method？"></a>3.为什么要使用 Native Method？</h3><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h4 id="3-1与Java环境外交互"><a href="#3-1与Java环境外交互" class="headerlink" title="3.1与Java环境外交互"></a>3.1与Java环境外交互</h4><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h4 id="3-2与操作系统的交互"><a href="#3-2与操作系统的交互" class="headerlink" title="3.2与操作系统的交互"></a>3.2与操作系统的交互</h4><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h4 id="3-3-Sun’s-Java"><a href="#3-3-Sun’s-Java" class="headerlink" title="3.3 Sun’s Java"></a>3.3 Sun’s Java</h4><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol><h4 id="3-4本地方法的现状"><a href="#3-4本地方法的现状" class="headerlink" title="3.4本地方法的现状"></a>3.4本地方法的现状</h4><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h2 id="4本地方法栈"><a href="#4本地方法栈" class="headerlink" title="4本地方法栈"></a>4本地方法栈</h2><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/java/JVM_03/0013.png" alt="jvm"></p><p><strong>注意事项</strong></p><ol><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_02类加载子系统</title>
      <link href="/2022/04/07/JVM-02%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/04/07/JVM-02%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="2类加载子系统"><a href="#2类加载子系统" class="headerlink" title="2类加载子系统"></a>2类加载子系统</h1><h2 id="1-内存结构概述"><a href="#1-内存结构概述" class="headerlink" title="1.内存结构概述"></a>1.内存结构概述</h2><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0001.png" alt="001"></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0003.png" alt="002"></p><p>注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有</p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ol><li>类加载器</li><li>执行引擎</li></ol><h2 id="2-类加载器子系统"><a href="#2-类加载器子系统" class="headerlink" title="2.类加载器子系统"></a>2.类加载器子系统</h2><p><strong>类加载器子系统作用：</strong></p><ol><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li><li><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0004.png" alt="003"></p><h2 id="3-类加载器ClassLoader角色"><a href="#3-类加载器ClassLoader角色" class="headerlink" title="3.类加载器ClassLoader角色"></a>3.类加载器ClassLoader角色</h2><ol><li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0005.png" alt="004"></p><h2 id="4-类加载过程"><a href="#4-类加载过程" class="headerlink" title="4.类加载过程"></a>4.类加载过程</h2><h3 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?</p><ul><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0006.png" alt="6"></p><p>完整的流程图如下所示：</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0007.png" alt="img"></p><h3 id="4-2加载阶段"><a href="#4-2加载阶段" class="headerlink" title="4.2加载阶段"></a>4.2加载阶段</h3><p><strong>加载：</strong></p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol><p><strong>加载class文件的方式：</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="4-3链接阶段"><a href="#4-3链接阶段" class="headerlink" title="4.3链接阶段"></a>4.3链接阶段</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h4 id="4-3-1验证-Verify"><a href="#4-3-1验证-Verify" class="headerlink" title="4.3.1验证(Verify)"></a>4.3.1验证(Verify)</h4><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><p><strong>举例</strong></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0008.png" alt="img"></p><h4 id="4-3-2-准备-Prepare"><a href="#4-3-2-准备-Prepare" class="headerlink" title="4.3.2 准备(Prepare)"></a>4.3.2 准备(Prepare)</h4><ol><li>为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li><li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-3解析-Resolve"><a href="#4-3-3解析-Resolve" class="headerlink" title="4.3.3解析(Resolve)"></a>4.3.3解析(Resolve)</h4><ol><li><strong>将常量池内的符号引用转换为直接引用的过程</strong></li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li></ol><p><strong>符号引用</strong></p><ul><li>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0023.png" alt="img"></p><h3 id="4-4初始化阶段"><a href="#4-4初始化阶段" class="headerlink" title="4.4初始化阶段"></a>4.4初始化阶段</h3><ul><li>类的初始化时机</li></ul><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h3 id="4-5clinit"><a href="#4-5clinit" class="headerlink" title="4.5clinit()"></a>4.5clinit()</h3><ol><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li></ol><blockquote><p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度</p></blockquote><h4 id="1，2，3说明"><a href="#1，2，3说明" class="headerlink" title="1，2，3说明"></a>1，2，3说明</h4><p><strong>举例1：有static变量</strong></p><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0009.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&lt;clint字节码&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> <span class="number">5</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span>     <span class="comment">//先赋20</span></span><br><span class="line"><span class="number">10</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">13</span> getstatic #<span class="number">2</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> getstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> bipush <span class="number">10</span>    <span class="comment">//再赋10</span></span><br><span class="line"><span class="number">24</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p><strong>举例2：无 static 变量</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0010.png" alt="img"></p><p>加上之后就有了</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0011.png" alt="img"></p><h4 id="4说明"><a href="#4说明" class="headerlink" title="4说明"></a>4说明</h4><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0012.png" alt="img"></p><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a>5说明</h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0013.png" alt="img"></p><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a>6说明</h4><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            <span class="type">DeadThread</span> <span class="variable">dead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadThread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">/然后程序卡死了</span><br></pre></td></tr></table></figure><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h2 id="5-类加载器的分类"><a href="#5-类加载器的分类" class="headerlink" title="5.类加载器的分类"></a>5.类加载器的分类</h2><h3 id="1概述"><a href="#1概述" class="headerlink" title="1概述"></a>1概述</h3><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0014.png" alt="jvm"></p><p><strong>ExtClassLoader</strong></p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0015.png" alt="jvm" style="zoom: 67%;" /><p><strong>AppClassLoader</strong></p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0016.png" alt="jvm" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C&#x2F;C++ 语言，我们获取不到</strong></li><li>两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h3 id="2-虚拟机自带的加载器"><a href="#2-虚拟机自带的加载器" class="headerlink" title="2.虚拟机自带的加载器"></a>2.虚拟机自带的加载器</h3><h4 id="2-1启动类加载器"><a href="#2-1启动类加载器" class="headerlink" title="2.1启动类加载器"></a>2.1启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="2-2扩展类加载器"><a href="#2-2扩展类加载器" class="headerlink" title="2.2扩展类加载器"></a>2.2扩展类加载器</h4><blockquote><p><strong>扩展类加载器（Extension ClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h4 id="2-3系统类加载器"><a href="#2-3系统类加载器" class="headerlink" title="2.3系统类加载器"></a>2.3系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/resources.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/rt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/sunrsasign.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/jsse.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/jce.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/charsets.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/jfr.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/classes</span><br><span class="line">null</span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@29453f44</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-用户自定义类加载器"><a href="#3-用户自定义类加载器" class="headerlink" title="3.用户自定义类加载器"></a>3.用户自定义类加载器</h3><h4 id="3-1什么时候需要自定义类加载器？"><a href="#3-1什么时候需要自定义类加载器？" class="headerlink" title="3.1什么时候需要自定义类加载器？"></a>3.1什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h4 id="3-2如何自定义类加载器？"><a href="#3-2如何自定义类加载器？" class="headerlink" title="3.2如何自定义类加载器？"></a>3.2如何自定义类加载器？</h4><ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">customClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="literal">true</span>, customClassLoader);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4关于ClassLoader"><a href="#4关于ClassLoader" class="headerlink" title="4关于ClassLoader"></a>4关于ClassLoader</h3><blockquote><p><strong>ClassLoader 类介绍</strong></p></blockquote><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0017.png" alt="img"></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p>[<img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0018.png" alt="img"></p><h4 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h4><p>[<img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0019.png" alt="img"  /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="6双亲委派机制"><a href="#6双亲委派机制" class="headerlink" title="6双亲委派机制"></a>6双亲委派机制</h2><h3 id="1双亲委派机制原理"><a href="#1双亲委派机制原理" class="headerlink" title="1双亲委派机制原理"></a>1双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0020.png" alt="img"></p><h3 id="2双亲委派机制代码演示"><a href="#2双亲委派机制代码演示" class="headerlink" title="2双亲委派机制代码演示"></a>2双亲委派机制代码演示</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,atguigu.com</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0021.png" alt="img"></p><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">package java.lang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ShkStart &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">java.lang.SecurityException: Prohibited package name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:761)</span><br><span class="line">at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class="line">at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)</span><br><span class="line">at java.net.URLClassLoader.access$100(URLClassLoader.java:73)</span><br><span class="line">at java.net.URLClassLoader$1.run(URLClassLoader.java:368)</span><br><span class="line">at java.net.URLClassLoader$1.run(URLClassLoader.java:362)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:361)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; </span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvm_2/0022.png" alt="img" style="zoom:67%;" /><h3 id="3-双亲委派机制优势"><a href="#3-双亲委派机制优势" class="headerlink" title="3.双亲委派机制优势"></a>3.双亲委派机制优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="7-沙箱安全机制"><a href="#7-沙箱安全机制" class="headerlink" title="7.沙箱安全机制"></a>7.沙箱安全机制</h2><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h2><h3 id="1-如何判断两个class对象是否相同？"><a href="#1-如何判断两个class对象是否相同？" class="headerlink" title="1.如何判断两个class对象是否相同？"></a>1.如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li><li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol><h3 id="2-对类加载器的引用"><a href="#2-对类加载器的引用" class="headerlink" title="2.对类加载器的引用"></a>2.对类加载器的引用</h3><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机与网络-总结</title>
      <link href="/2022/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C-%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机与网络"><a href="#计算机与网络" class="headerlink" title="计算机与网络"></a>计算机与网络</h1><h2 id="1对称加密与非对称加密"><a href="#1对称加密与非对称加密" class="headerlink" title="1对称加密与非对称加密"></a>1对称加密与非对称加密</h2><h3 id="1-1对称加密"><a href="#1-1对称加密" class="headerlink" title="1.1对称加密"></a>1.1<strong>对称加密</strong></h3><p>密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p><strong>存在的问题:</strong> 这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方,对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><h3 id="1-2-非对称加密："><a href="#1-2-非对称加密：" class="headerlink" title="1.2. 非对称加密："></a><strong>1.2.</strong> <strong>非对称加密</strong>：</h3><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p>使用非对称密钥时，小黑和小红都需要用计算机产生一对属于自己的密钥，公钥加密的信息只有其对应的私钥才能解开，且公钥和私钥之间不能互推。</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt="非对称加密" style="zoom: 67%;" /><p>首先需要交换它们的公钥</p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%862.jpg" alt="非对称加密" style="zoom:67%;" /><p>然后小黑向小红发送敏感文件时可以用小红的公钥进行加密后传给小红，加密后的数据只能由小红的私钥才能解开，小黑也不能解开数据</p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%863.png" alt="非对称加密"></p><h4 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h4><p><strong>非对称加密</strong>：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><h2 id="2-三次握手和四次挥手"><a href="#2-三次握手和四次挥手" class="headerlink" title="2.三次握手和四次挥手"></a>2.三次握手和四次挥手</h2><h3 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h3><p>​    <img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E9%A6%96%E9%83%A8.webp" alt="tcp报文首部"></p><ul><li><ol><li><strong>源端口和目的端口</strong>:    各占2个字节，分别写入源端口和目的端口；</li></ol></li><li><ol start="2"><li><strong>序号</strong>:  占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li></ol></li><li><ol start="3"><li><strong>确认号</strong>:   占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；****若确认号为&#x3D; N，则表明：到序号N-1为止的所有数据都已正确收到****。</li></ol></li><li><ol start="4"><li><strong>数据偏移</strong>：  占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。</li></ol></li><li><ol start="5"><li><strong>保留</strong> ：   占6位，保留为今后使用，但目前应置为0 。</li></ol></li></ul><p><strong>下面有6个控制位，用来说明本报文段的性质。</strong></p><ul><li><ol start="6"><li><strong>紧急URG：</strong> 当URG&#x3D;1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li></ol></li><li><ol start="7"><li><strong>确认ACK</strong>：  仅当ACK&#x3D;1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li></ol></li><li><ol start="8"><li><strong>推送PSH</strong>:   当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH&#x3D;1</li></ol></li><li><ol start="9"><li><strong>复位RST</strong>:     当RST&#x3D;1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li></ol></li><li><ol start="10"><li><strong>同步SYN</strong>:    在连接建立时用来同步序号。当SYN&#x3D;1，ACK&#x3D;0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN&#x3D;1，ACK&#x3D;1；</li></ol></li><li><ol start="11"><li><strong>终止FIN</strong>:     用来释放连接。当FIN&#x3D;1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li></ol></li><li><ol start="12"><li><strong>窗口</strong>:  占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</li></ol></li><li><ol start="13"><li><strong>检验和:</strong>   占2字节，校验首部和数据这两部分；</li></ol></li><li><ol start="14"><li><strong>紧急指针</strong> :   占2字节。紧急指针仅在URG&#x3D;1时才有意义,指出本报文段中的紧急数据的字节数；</li></ol></li><li><ol start="15"><li><em><strong>*选项*</strong></em>    长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节</li></ol></li></ul><h3 id="回答：-1"><a href="#回答：-1" class="headerlink" title="回答："></a>回答：</h3><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif" alt="三次握手"></p><h4 id="2-1三次握手"><a href="#2-1三次握手" class="headerlink" title="2.1三次握手"></a><strong>2.1三次握手</strong></h4><ul><li>第一次握手：客户端向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>第二次握手：TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>第三次握手：TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，确认号ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li></ul><h4 id="2-2为什么不能两次握手？"><a href="#2-2为什么不能两次握手？" class="headerlink" title="2.2为什么不能两次握手？"></a><strong>2.2为什么不能两次握手？</strong></h4><p>为防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果客户端第一次握手发送SYN包确定连接时，可能因为某些原因发生滞留，并没有到达服务器，客户端为了建立连接会再发送一个SYN包去连接。如果两次握手的话，服务端返回SYN包和ACK包就建立了连接，而如果这时滞留的SYN包恢复连接到达服务端，则服务端认为这是第二个连接，进入等待数据状态。返回ACK包和SYN包。而客户端认为只建立了一个连接。造成状态不一致，这将导致不必要的错误和资源的浪费。如果三次握手。服务端收不到最后的ACK包。则不会认为建立连接成功。</p><h4 id="2-3四次挥手"><a href="#2-3四次挥手" class="headerlink" title="2.3四次挥手"></a><strong>2.3四次挥手</strong></h4><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.gif" alt="四次挥手"></p><blockquote><p>客户端和服务端都可以发送关闭连接请求</p></blockquote><p>比如客户端初始化的序列号ISA&#x3D;100，服务端初始化的序列号ISA&#x3D;300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p><ul><li>第一次挥手：当客户端的数据都传输完成后（数据没发送完也可以请求，要停止发送数据）。客户端向服务端发出连接释放报文，释放连接报文包含FIN标志位(FIN&#x3D;1)、序列号seq&#x3D;1101(等于前面已经传送过来的数据的最后一个字节的序号加1，100+1+1000，其中的1是建立连接时占的一个序列号)，此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。                <u><strong>注意</strong></u>：    此时的客户端不能再发数据了，但可以接受数据</li><li>第二次挥手： 服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK&#x3D;1)、确认号ack&#x3D;1102(客户端FIN报文序列号1101+1)、序列号seq&#x3D;2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）</li><li>第三次挥手： 服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN&#x3D;1,ACK&#x3D;1)、确认号和第二次挥手一样ack&#x3D;1102、序列号seq&#x3D;2350(2300+50)。服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认</li><li>第四次挥手： 客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK&#x3D;1)、确认号ack&#x3D;2351、序列号seq&#x3D;1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li></ul><h4 id="2-4如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#2-4如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="2.4如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a><strong>2.4如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h4 id="2-5为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#2-5为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="2.5为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a><strong>2.5为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></h4><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h2 id="3HTTP和HTTPS"><a href="#3HTTP和HTTPS" class="headerlink" title="3HTTP和HTTPS"></a>3HTTP和HTTPS</h2><h3 id="理解：-2"><a href="#理解：-2" class="headerlink" title="理解："></a>理解：</h3><p>https传输过程中有三个密钥。</p><ul><li>服务器端生成的公钥和私钥，非对称加密。用于传输对称加密的密钥</li><li>客户端生成的随机密钥，用于对称加密</li></ul><p><strong>传输过程：</strong></p><ol><li>客户端向服务器发起HTTPS请求，连接到服务器的443端口。</li><li>服务器端生成一对公钥和私钥。私钥不能泄漏，公钥可以任意发送。（详见上面对称加密和非对称加密）</li><li>服务器把公钥发给客户端</li><li>客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。【严格的说，这里应该是验证服务器发送的数字证书的合法性】如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ol><h3 id="3-1-区别"><a href="#3-1-区别" class="headerlink" title="3.1 区别"></a>3.1 区别</h3><ul><li>http默认使用端口为80，https默认使用端口为443</li><li>http传输是明文传输，不安全。HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机与网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2022/04/05/linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/05/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="一简介"><a href="#一简介" class="headerlink" title="一简介"></a>一简介</h2><p><strong>Linux一切皆文件</strong></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/linux/linux1.png" alt="sdsda"></p><h3 id="1-1具体的目录结构（了解）"><a href="#1-1具体的目录结构（了解）" class="headerlink" title="1.1具体的目录结构（了解）"></a>1.1具体的目录结构（了解）</h3><ul><li><p>&#x2F;bin[常用]（&#x2F;user&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin）是binary的缩写。存放最经常使用的命令</p></li><li><p>&#x2F;sbin[常用]（&#x2F;user&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin）s是super user存放的是系统管理员使用的系统管理程序</p></li><li><p>&#x2F;home 【常用】 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录是以用户的账号命名</p></li><li><p>&#x2F;root 【常用】 该目录为系统管理员，也称作超级权限者的用户主目录</p></li><li><p>&#x2F;lib 系统开机所需要的最基本的动态链接共享库，起作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</p></li><li><p>&#x2F;lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</p></li><li><p>&#x2F;etc 【常用】所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库，my.conf</p></li><li><p>&#x2F;usr 【常用】这是一个非常重要的目录，用户很多应用程序都放在这个目录下，类似于windows下的program files目录。</p></li><li><p>&#x2F;boot 【常用】存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</p></li><li><p>&#x2F;proc 这个目录是一个虚拟的目录，他是系统内存的映射，访问这个目录来获取系统信息</p></li><li><p>&#x2F;srv      service缩写，该目录存放一些服务器启动后需要提取的数据</p></li><li><p>&#x2F;sys     这是linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs</p></li><li><p>&#x2F;tmp这个目录是用来存放一些临时文件的</p></li><li><p>&#x2F;dev类似于windows的设备管理器，把所有的硬件用文件的形式存储</p></li><li><p>&#x2F;media【常用】linux系统会自动识别一些设备，例如U盘，光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</p></li><li><p>&#x2F;mnt 【常用】系统提供该目录是为了让用户临时挂载别的系统文件，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里面的内容了。D:&#x2F;mushare</p></li><li><p>&#x2F;opt 这是给主机额外的安装软件所存放的目录。如安装ORACLE数据库就可以放到该目录下。默认为空</p></li><li><p>&#x2F;usr&#x2F;local【常用】 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码的方式安装的程序</p></li><li><p>&#x2F;var 【常用】这个目录中存放着在不断扩充的东西 ，习惯的将经常修改的目录放在这个目录下。包括各种日志文件</p></li><li><p>&#x2F;selinux 【security-enhanced linux】</p></li></ul><p>SELinux是一种安全子系统，他能控制程序自能访问特定的文件，有三种工作模式，可以自行设置</p><ul><li>查看IP地址ens33:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li>重启linux系统</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="二介绍"><a href="#二介绍" class="headerlink" title="二介绍"></a>二介绍</h2><h3 id="2-1vi和vim"><a href="#2-1vi和vim" class="headerlink" title="2.1vi和vim"></a>2.1vi和vim</h3><p>Linux系统会内置vi文本编辑器</p><p>Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译错误跳转等方便编程的功能相当丰富，在程序员中被广泛使用。（vim就是vi的增强版）</p><h3 id="2-2-vi和vim常用的三种模式"><a href="#2-2-vi和vim常用的三种模式" class="headerlink" title="2.2 vi和vim常用的三种模式"></a>2.2 vi和vim常用的三种模式</h3><p>正常模式<br>以vim打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，可以使用【上下左右】键来移动光标，你可以使用【删除字符】或【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据。</p><p>插入模式<br>按下i，I，o，O，a，A，r，R等任何一个字母之后才会进入编辑模式，一般来说按i就可</p><p>命令行模式<br>在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等动作则是在此模式中达成的！</p><p><img src="https://img-blog.csdnimg.cn/20210620104147374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjMyNDE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>使用</p><p>在一般模式下</p><p>1.拷贝当前行 yy，拷贝当前行向下的5行  5yy，并粘贴（输入p）</p><p>2.删除当前行 dd，删除当前向下5行 5dd</p><p>3查找某个单词按&#x2F;关键次。回车查找。输入n是查找下一个</p><p>4设置文件的行号，取消文件的行号命令行下【:set nu和:set nonu】</p><p>5使用快捷键到该文档的最末行（G）和最首行【gg】</p><p>6撤销【u】</p><p>7.快速到达文档某一行。输入20，在输入shift+g</p><h3 id="2-3关机重启命令"><a href="#2-3关机重启命令" class="headerlink" title="2.3关机重启命令"></a>2.3关机重启命令</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now   立刻进行关机-h是halt停止的意思</span><br><span class="line">shutdown -h 11分钟后关机</span><br><span class="line">shutdowm -r now    立刻重启计算机</span><br><span class="line">halt立刻进行关机</span><br><span class="line">reboot          立刻重启计算机</span><br><span class="line"><span class="built_in">sync</span>把内存的数据同步到磁盘</span><br></pre></td></tr></table></figure><h3 id="2-4用户登录和注销"><a href="#2-4用户登录和注销" class="headerlink" title="2.4用户登录和注销"></a>2.4用户登录和注销</h3><p>基本介绍<br>1、登陆时尽量少用root账号登录，因为他是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登陆后再用”su - 用户名“命令来切换成系统管理员身份</p><p>2、在提示符下输入logout即可注销用户</p><p>使用细节<br>logout注销指令在图形运行级别无效，在shell界面有效</p><h3 id="2-5、用户管理"><a href="#2-5、用户管理" class="headerlink" title="2.5、用户管理"></a>2.5、用户管理</h3><h4 id="2-5-1基本介绍"><a href="#2-5-1基本介绍" class="headerlink" title="2.5.1基本介绍"></a>2.5.1基本介绍</h4><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><h4 id="2-5-2添加用户"><a href="#2-5-2添加用户" class="headerlink" title="2.5.2添加用户"></a>2.5.2添加用户</h4><ul><li>基本语法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名</span><br></pre></td></tr></table></figure><p>实列(root权限下)<br>useradd che<br>添加一个用户chucheng，默认该用户的家目录在&#x2F;home&#x2F;che</p><p>细节说明<br>1、当用户创建成功后果，会自动的创建和用户同名的家目录<br>2、也可以通过useradd -d 指定目录  新的用户名     来给新创建的用户指定家目录</p><h4 id="2-5-3指定-x2F-修改密码"><a href="#2-5-3指定-x2F-修改密码" class="headerlink" title="2.5.3指定&#x2F;修改密码"></a>2.5.3指定&#x2F;修改密码</h4><ul><li>基本语法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></table></figure><h4 id="2-5-4-删除用户"><a href="#2-5-4-删除用户" class="headerlink" title="2.5.4 删除用户"></a>2.5.4 删除用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel   用户名    删除用户，但是要保留目录</span><br><span class="line">userdel -r 用户名删除用户以及用户主目录 </span><br></pre></td></tr></table></figure><h4 id="2-5-5查询用户信息指令"><a href="#2-5-5查询用户信息指令" class="headerlink" title="2.5.5查询用户信息指令"></a>2.5.5查询用户信息指令</h4><ul><li>基本语法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> 用户名</span><br></pre></td></tr></table></figure><h4 id="2-5-6切换用户"><a href="#2-5-6切换用户" class="headerlink" title="2.5.6切换用户"></a>2.5.6切换用户</h4><ul><li>介绍</li></ul><p>在操作Linux时，如果当前用户的权限不够，可以通过su - 指令，切换到更高权限的用户，如root</p><ul><li>基本语法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - 用户名</span><br></pre></td></tr></table></figure><ul><li>细节说明</li></ul><p>1.从权限高的用户切换到权限低的用户时，不需要输入密码，反之需要</p><p>2.当需要返回到原来用户时，使用exit&#x2F;logout指令</p><h4 id="2-5-7-查看当前用户-x2F-登录用户"><a href="#2-5-7-查看当前用户-x2F-登录用户" class="headerlink" title="2.5.7 查看当前用户&#x2F;登录用户"></a>2.5.7 查看当前用户&#x2F;登录用户</h4><ul><li>基本语法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span>/who am i</span><br></pre></td></tr></table></figure><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/linux/linux2.png" alt="sdss"></p><h4 id="2-5-8-用户组"><a href="#2-5-8-用户组" class="headerlink" title="2.5.8 用户组"></a>2.5.8 用户组</h4><ul><li>介绍</li></ul><p>类似于角色，系统可以对有共性&#x2F;权限的多个用户进行统一的管理</p><ul><li>新增组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令：groupadd 组名</span><br></pre></td></tr></table></figure><ul><li>删除组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令（基本语法）：groupdel 组名</span><br></pre></td></tr></table></figure><ul><li><p>注意：如果当添加用户时没有指定组，会默认创建和这个用户同名的组，同时把用户放到该组里</p></li><li><p>增加用户时直接加上组</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令：useradd -g 用户组 用户名</span><br></pre></td></tr></table></figure><ul><li>移动组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g 组名 用户名</span><br></pre></td></tr></table></figure><h4 id="2-5-9-用户和组相关文件"><a href="#2-5-9-用户和组相关文件" class="headerlink" title="2.5.9 用户和组相关文件"></a>2.5.9 用户和组相关文件</h4><p>&#x2F;etc&#x2F;passwd 文件<br>用户（user）的配置文件，记录用户的各种信息</p><p>每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</p><p>&#x2F;etc&#x2F;shadow文件<br>口令配置文件</p><p>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p><p>&#x2F;etc&#x2F;group文件<br>组（group）的配置文件，记录Linux包含的组的信息</p><p>每行含义：组名：口令：组标识号：组内用户列表</p><h2 id="三、Linux实践——实用指令"><a href="#三、Linux实践——实用指令" class="headerlink" title="三、Linux实践——实用指令"></a>三、Linux实践——实用指令</h2><h3 id="3-1指定运行级别"><a href="#3-1指定运行级别" class="headerlink" title="3.1指定运行级别"></a>3.1指定运行级别</h3><ul><li>基本介绍</li></ul><p>运行级别说明：</p><p>0：关机</p><p>1：单用户【找回丢失密码】</p><p>2：多用户状态没有网络服务</p><p>3：多用户状态有网络服务</p><p>4：系统未使用保留给用户</p><p>5：图形界面                graphical.target</p><p>6：系统重启</p><p>常用运行级别是3和5，也可以指定默认运行级别</p><ul><li>应用实例</li></ul><p>命令：init[0123456]应用案例：通过init来切换不同的运行级别，比如动5-3，然后关机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看当前的运行级别   systemctl get-ddefault</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改变为   systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure><h3 id="3-2-root密码丢失"><a href="#3-2-root密码丢失" class="headerlink" title="3.2 root密码丢失"></a>3.2 root密码丢失</h3><ul><li>在启动开机页面按e进入编辑页面</li><li>在编辑页面，向下移动，找到以“Linux16”开头的所在行，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh</li><li>输入完后按ctrl+x 进入单用户模式</li><li>接着在光标闪烁的地方输入： mount -o remount,rw &#x2F; (注意空格)完成后输入enter</li><li>在新的一行输入   passwd   ，完成后回车键。输入密码，确认密码。完成后会出现passwd。。。式样。修改成功</li><li>接着在鼠标闪烁的地方输入：  touch &#x2F;.autorelabel  (注意touch 与&#x2F;后面有一个空格)</li><li>输入exec &#x2F;sbin&#x2F;init</li></ul><h3 id="3-3帮助指令"><a href="#3-3帮助指令" class="headerlink" title="3.3帮助指令"></a>3.3帮助指令</h3><ul><li>man获得帮助信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：man [命令或配置文件]（功能描述：获得帮助信息）</span><br></pre></td></tr></table></figure><p>在linux下隐藏文件是以 “.” 开头的</p><ul><li>help指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="built_in">help</span> 命令 （功能描述：获得shell内置命令的帮助信息）</span><br></pre></td></tr></table></figure><h3 id="3-4文件目录类"><a href="#3-4文件目录类" class="headerlink" title="3.4文件目录类"></a>3.4文件目录类</h3><ul><li>pwd指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="built_in">pwd</span>    （功能描述：显示当前工作目录的绝对路径）</span><br></pre></td></tr></table></figure><hr><ul><li>ls指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="built_in">ls</span> [选项] [目录或是文件]</span><br></pre></td></tr></table></figure><p>常用选项</p><p>-a ： 显示当前目录所有的文件和目录，包括隐藏的</p><p>-l ： 以列表的方式显示信息</p><ul><li>cd指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="built_in">cd</span> [参数] （功能描述：切换到指定的目录）</span><br></pre></td></tr></table></figure><p>理解：绝对路径和相对路径（相对路径是针对当前位置的路径）</p><p>cd ~ 或者cd 回到自己的家目录</p><p>cd … 回到当前目录的上一级目录</p><ul><li>mkdir指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="built_in">mkdir</span> [选项] 要创建的目录</span><br></pre></td></tr></table></figure><p>理解：mkdir指令用于创建目录（默认只能创建一级目录）</p><p>-p :创建多级目录</p><hr><ul><li>rmdir指令（用于删除空目录）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="built_in">rmdir</span> [选项] 要删除的空目录</span><br></pre></td></tr></table></figure><p>使用细节：</p><p>rmdir删除的是空目录，如果欲删除的目录下有内容则无法删除</p><p>&#x3D;&#x3D;如果需要删除非空目录，需要使用rm -rf 要删除的目录</p><ul><li>touch指令（用于创建空文件）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> 文件名称</span><br></pre></td></tr></table></figure><ul><li>cp指令（copy拷贝文件导指定目录）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] <span class="built_in">source</span> dest</span><br></pre></td></tr></table></figure><p>常用选项：-r 递归复制真个文件夹</p><p>应用实例:</p><p>将 &#x2F;home&#x2F;hello.txt 拷贝到 &#x2F;home&#x2F;bbb 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /home/hello.txt /home/bbb</span><br></pre></td></tr></table></figure><p>递归复制整个文件夹，将&#x2F;home&#x2F;aaa 目录下的文件全部拷贝到&#x2F;home&#x2F;bbb下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /home/aaa /hom/bbb</span><br><span class="line">(是将整个目录和目录本身拷贝进来)</span><br></pre></td></tr></table></figure><p>使用强制覆盖不提示的方法：\cp</p><ul><li>rm指令（remove，移除文件或目录）&#x3D;一定要小心！！！<br>基本语法：rm [选项] 要删除的文件或目录</li></ul><p>常用选项</p><p>-r : 递归删除整个文件夹</p><p>-f ：强制删除不提示</p><p>使用细节：强制删除不提示的方式，带上-f参数即可</p><ul><li>mv指令（move，移动文件与目录或重命名)（以可剪切文件夹）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> oldNameFile newNamefile (功能描述：重命名)</span><br><span class="line"><span class="built_in">mv</span> /temp/movefile /targetFolder (功能描述：移动文件，剪切)</span><br></pre></td></tr></table></figure><ul><li>cat指令（查看文件内容）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [选项] 要查看的文件</span><br></pre></td></tr></table></figure><p>常用选项： -n 显示行号</p><p>使用细节：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 |more</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n /etc/profile |more</span><br></pre></td></tr></table></figure><ul><li>more指令</li></ul><p>more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键（交互的指令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：more 要查看的文件</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210622081656367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjMyNDE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>echo指令</li></ul><p>echo输出内容到控制台</p><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 【选项】【输出内容】</span><br></pre></td></tr></table></figure><p>应用实例</p><p>案例：使用echo指令输出环境变量 $PATH  $HOSTNAME.      echo  $PATH</p><p>案例：使用echo指令输出helloworld.      echo “helloworld”</p><ul><li><p>head</p><p>用于显示文件的开头部分内容。默认是前十行的内容</p><p>基本语法</p><p>head 文件</p><p>head -n 5 文件（功能描述：查看文件头5行内容，5可以是任意数字）</p></li><li><p>tail</p></li></ul><p>用于显示文件的尾部部分内容。</p><p>tail 文件</p><p>tail -n 5 文件（功能描述：查看文件头5行内容，5可以是任意数字）</p><p>tail -f 文件（功能描述：实时追踪该文件的所有更新）</p><p>比如说。在一个窗口输入tail -f mydata.txt.此窗口就在实时监控这个文件</p><p>当再打开一个控制器echo “hello” &gt;mydata.txt.则在监控窗口实时出现hello。</p><ul><li>&gt;重定向覆盖</li><li>&gt;&gt;追加</li></ul><p>基本语法：</p><p>1）ls -l &gt;文件     （功能描述：列表的内容写入文件a .txt中（覆盖写））</p><p>2）ls -al &gt;&gt;文件    （功能描述：列表的内容追加到文件a.txt的末尾）</p><p>3）cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）</p><p>4）echo “内容” &gt;&gt; 文件</p><p>应用案例：</p><ul><li><p>将&#x2F;home目录下的文件列表，写入到&#x2F;home&#x2F;info.txt中</p></li><li><p>将当前日历信息追加到&#x2F;home&#x2F;mycal文件中</p></li><li><p>ln指令</p></li></ul><p>软连接也称为符号链接，类似于windows里的快捷键方式，主要存放了连接其他文件的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：<span class="built_in">ln</span> -s [原文件或目录] [软链接名]（功能描述：给原文件创建一个软链接）</span><br></pre></td></tr></table></figure><p>案例一：在&#x2F;home目录下创建一个软链接myroot，连接到&#x2F;root目录</p><p>ln -s &#x2F;root  &#x2F;home&#x2F;myroot</p><p>案例二：删除软链接myroot</p><p>rm &#x2F;home&#x2F;myroot</p><ul><li>history指令</li></ul><p>查看已经执行过历史命令，也可以执行历史指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span>  显示所有的历史命令</span><br><span class="line"><span class="built_in">history</span> 10    显示最近使用过的10个指令</span><br><span class="line">!5   执行历史编号为5的指令</span><br></pre></td></tr></table></figure><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><ul><li>date指令-显示当前日期</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基本语法：</span><br><span class="line"><span class="built_in">date</span>显示当前时间</span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y&quot;</span>显示当前年份   小写y只显示后面2位22</span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%m&quot;</span>显示当前月份</span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%d&quot;</span>显示当前是哪一天</span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span> 显示年月日时分秒</span><br></pre></td></tr></table></figure><p>date指令还可以设置日期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -s 字符串时间</span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2021-6-20 16:44:30&quot;</span></span><br></pre></td></tr></table></figure><ul><li>cal指令</li></ul><p>查看日历指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal [选项]      （功能描述：不加选项，显示本月日历）</span><br><span class="line">cal 2021      显示2021整年的日历</span><br></pre></td></tr></table></figure><h3 id="6-5搜索查找类"><a href="#6-5搜索查找类" class="headerlink" title="6.5搜索查找类"></a>6.5搜索查找类</h3><ul><li><p>find指令</p><p>find指令指令 将从指定目录向下递归遍历各个子目录，将满足条件的文件或者目录显示在终端上</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [搜索范围] [选项]</span><br></pre></td></tr></table></figure><p>选项说明（可填选项）</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件</td></tr></tbody></table><p>说明：当查询路径下无该文件，就不会有任何显示</p><p>应用实例：</p><ul><li><p>按文件名：根据名称查找&#x2F;home目录下的hello.txt文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name hello.txt</span><br></pre></td></tr></table></figure></li><li><p>按拥有者：查找&#x2F;opt目录下，用户名称为nobody的文件</p></li><li><p>查找整个linux系统下大于200M的文件（+n大于 -n小于 n等于,单位：k，M，G）</p></li></ul><p>ls -lh</p><ul><li><p>locate指令</p><p>locate指令可以快速定位文件路径。locate命令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位的文件名。Locate指令无需遍历整个文件系统，查询速度较快。为了保障查询结果的准确度，管理员必须定期更新locate时刻</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：locate 搜索文件</span><br></pre></td></tr></table></figure><p>特别说明：由于locate指令基于数据进行查询，所以第一次运行前，必须是使用updatedb指令创建locate数据库</p><ul><li><p>which指令 ，可以查看某个指令在哪个目录下</p></li><li><p>grep指令和管道符号 |</p></li></ul><p>grep过滤查找，管道符，“|“，表示将前一个命令输出传递给后面的命令处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本语法：grep [选项] 查找内容 源文件</span><br></pre></td></tr></table></figure><p>选项：</p><p>-n 显示匹配行及行号</p><p>-i 忽略字母大小写</p><p>两种写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /home/hello.txt |grep -n <span class="string">&quot;yes&quot;</span>       hello.txt文件夹中输出同样的</span><br><span class="line">grep -n <span class="string">&quot;yes&quot;</span> /home/hello.txt</span><br></pre></td></tr></table></figure><h4 id="6-6-压缩和解压"><a href="#6-6-压缩和解压" class="headerlink" title="6.6 压缩和解压"></a>6.6 压缩和解压</h4><ul><li>gzip&#x2F;gunzip指令</li></ul><p>gzip用于压缩文件，gunzip用于解压文件的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip文件（功能描述：压缩文件，只能将文件压缩为*.gz文件</span><br><span class="line">gunzip文件    （功能描述：解压文件命令）</span><br></pre></td></tr></table></figure><ul><li>zip&#x2F;unzip指令</li></ul><p>zip用于压缩文件，unzip用于解压的，在整个项目打包发布中很有用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] xxx.zip 将要压缩的内容（一般是文件和文件夹）</span><br><span class="line">uzip [选项] xxx.zip （功能描述：解压文件）</span><br></pre></td></tr></table></figure><p>zip的常用项： -r 递归压缩，即压缩目录</p><p>zip -r myhome.zip &#x2F;home&#x2F;</p><p>unzip的常用项 ： -d&lt;目录&gt; : 指定解压后文件的存放目录</p><p>unzip -d</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5</title>
      <link href="/2022/04/03/spring5/"/>
      <url>/2022/04/03/spring5/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring——IOC（控制反转）"><a href="#Spring——IOC（控制反转）" class="headerlink" title="Spring——IOC（控制反转）"></a>Spring——IOC（控制反转）</h1><h2 id="一、IOC容器"><a href="#一、IOC容器" class="headerlink" title="一、IOC容器"></a>一、IOC容器</h2><h3 id="1、什么是IOC（控制反转）"><a href="#1、什么是IOC（控制反转）" class="headerlink" title="1、什么是IOC（控制反转）"></a>1、什么是IOC（控制反转）</h3><ul><li><p>a）把对象创建和对象之间的调用过程，交给Spring进行管理</p></li><li><p>b）使用IOC目的：为了降低耦合度</p></li></ul><h3 id="2、IOC底层原理"><a href="#2、IOC底层原理" class="headerlink" title="2、IOC底层原理"></a>2、IOC底层原理</h3><ul><li>a）xml解析     b)工厂模式         C)反射</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/spring/origin.png" alt="ys"></p><p>​                             <img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/spring/factory.png" alt="gc"></p><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/spring/IOC.png" alt="ioc"></p><ul><li>IOC（接口）</li></ul><p>1、IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p><h3 id="3、Spring提供的IOC容器实现的两种方式（两个接口）"><a href="#3、Spring提供的IOC容器实现的两种方式（两个接口）" class="headerlink" title="3、Spring提供的IOC容器实现的两种方式（两个接口）"></a>3、Spring提供的IOC容器实现的两种方式（两个接口）</h3><ul><li><p>a）BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。）</p></li><li><p>b）ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载spring配置文件</span></span><br><span class="line">ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationText</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="4、ApplicationContext接口的实现类（具体根据API文档查看☺）"><a href="#4、ApplicationContext接口的实现类（具体根据API文档查看☺）" class="headerlink" title="4、ApplicationContext接口的实现类（具体根据API文档查看☺）"></a>4、ApplicationContext接口的实现类（具体根据API文档查看☺）</h3><p>在idea中选中ApplictionContext上按control+h查看</p><p>![api](&#x2F;Users&#x2F;xiaoluyouqu&#x2F;Desktop&#x2F;截屏2022-01-23 下午5.00.12.png)</p><h2 id="二、IOC容器-Bean管理"><a href="#二、IOC容器-Bean管理" class="headerlink" title="二、IOC容器-Bean管理"></a>二、IOC容器-Bean管理</h2><h3 id="1、IOC操作Bean管理"><a href="#1、IOC操作Bean管理" class="headerlink" title="1、IOC操作Bean管理"></a>1、IOC操作Bean管理</h3><ul><li>a）Bean管理就是两个操作：（1）Spring创建对象；（2）Spring注入属性</li></ul><h3 id="2、Bean管理操作有两种方式"><a href="#2、Bean管理操作有两种方式" class="headerlink" title="2、Bean管理操作有两种方式"></a>2、Bean管理操作有两种方式</h3><ul><li>1）基于XML配置文件创建对象</li><li>2）基于注解方式实现。</li></ul><h4 id="2-1基于XML配置文件创建对象"><a href="#2-1基于XML配置文件创建对象" class="headerlink" title="2.1基于XML配置文件创建对象"></a>2.1基于XML配置文件创建对象</h4><p><strong>基于XML配置文件创建对象</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 配置User对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(1)在spring配置文件中，使用bean标签，标签里添加对应的属性，就可以实现对象创建</p><p>(2)bean标签中常用属性介绍：</p><ul><li>id属性   唯一标识</li><li>class属性:类全路径</li></ul><p>(3)创建对象时，默认执行无参数构造方法</p><p><strong>基于xml方式注入属性</strong></p><p>(1)DI:依赖注入，就是注入属性</p><ul><li>1.使用set方法注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）传统方式： 创建类，定义属性和对应的set方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        <span class="comment">//创建属性</span></span><br><span class="line">        <span class="keyword">private</span> String bname;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建属性对应的set方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBname</span><span class="params">(String bname)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bname = bname;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Book book=<span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.seBname(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--（2）spring方式： set方法注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property完成属性注入</span></span><br><span class="line"><span class="comment">        name：类里面属性名称</span></span><br><span class="line"><span class="comment">        value：向属性注入的值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bauthor&quot;</span> <span class="attr">value</span>=<span class="string">&quot;World&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(2)spring方式测试。在一个类中</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Book&#123;bname=<span class="string">&#x27;Hello&#x27;</span>, bauthor=<span class="string">&#x27;World&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>2使用有参构造注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">        <span class="comment">//创建属性</span></span><br><span class="line">        <span class="keyword">private</span> String oname;</span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String oname,String address)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.oname=oname;</span><br><span class="line">          <span class="built_in">this</span>.address=address;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//（1）传统有参注入</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Book book=<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--（2）spring方式：有参数构造注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;China！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>3、p名称空间注入（了解即可）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1、添加p名称空间在配置文件头部--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>&lt;!<span class="attr">--</span>在这里添加一行<span class="attr">p--</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2、在bean标签进行属性注入（算是set方式注入的简化操作）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span> <span class="attr">p:bname</span>=<span class="string">&quot;very&quot;</span> <span class="attr">p:bauthor</span>=<span class="string">&quot;good&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>4注入空值和特殊符号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--（1）null值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="comment">&lt;!--属性里边添加一个null标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--（2）特殊符号赋值--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--属性值包含特殊符号</span></span><br><span class="line"><span class="comment">       a 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span></span><br><span class="line"><span class="comment">       b 把带特殊符号内容写到CDATA</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注入属性-外部bean</strong></p><p> a）创建两个类service和dao类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始方式：创建UserDao对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spring方式创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//创建UserDao类型属性，生成set方法</span></span><br><span class="line">  <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add...............&quot;</span>);</span><br><span class="line">        userDao.update();<span class="comment">//调用dao方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b)在spring配置文件中设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 service和dao对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.service.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入userDao对象</span></span><br><span class="line"><span class="comment">        name属性：类里面属性名称</span></span><br><span class="line"><span class="comment">        ref属性：创建userDao对象bean标签id值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于XML方式注入内部bean和级联赋值</strong></p><p>a）注入属性-内部bean</p><blockquote><p> 1）一对多关系：部门和员工<br> 一个部门有多个员工，一个员工属于一个部门（部门是一，员工是多）<br> 2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部门类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDname</span><span class="params">(String dname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dname = dname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="comment">//员工属于某一个部门，使用对象形式表示</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDept</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEname</span><span class="params">(String ename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ename = ename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在spring配置文件中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--内部bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Andy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置对象类型属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span><span class="comment">&lt;!--内部bean赋值--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;宣传部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> (4）注入属性-级联赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一：级联赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Andy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;公关部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式二：生成dept的get方法（get方法必须有！！）</span></span><br><span class="line">   <span class="keyword">public</span> Dept <span class="title function_">getDept</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> dept;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--设置两个普通属性--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jams&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--级联赋值--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>IOC 操作 Bean 管理——xml 注入集合属性</strong></p><blockquote><p> 1、注入数组类型属性 2、注入 List 集合类型属性 3、注入 Map 集合类型属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="comment">//1 数组类型属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] courses;</span><br><span class="line">    <span class="comment">//2 list集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//3 map集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line">    <span class="comment">//4 set集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourses</span><span class="params">(String[] courses)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.courses = courses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--（2）在 spring 配置文件进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--list类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>小三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--map类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>2、在集合里面设置对象类型值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生所学多门课程</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Course&gt; courseList;<span class="comment">//创建集合</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCourseList</span><span class="params">(List&lt;Course&gt; courseList)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.courseList = courseList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--创建多个course对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">&lt;!--注入list集合类型，值是对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一步：在 spring 配置文件中引入名称空间 util--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span> &lt;!<span class="attr">--</span>添加<span class="attr">util</span>名称空间<span class="attr">--</span>&gt;</span></span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;  <span class="comment">&lt;!--添加util名称空间--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--第二步：使用 util 标签完成 list 集合注入提取--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--把集合注入部分提取出来--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--1 提取list集合类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--2 提取list集合类型属性注入使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>IOC 操作 Bean 管理（FactoryBean）</strong></p><blockquote><p>1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</p></blockquote><blockquote><p>2、普通 bean：在配置文件中定义 bean 类型就是返回类型</p></blockquote><blockquote><p>3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 </p><p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean </p><p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Course&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义返回bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Course <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Course</span>();</span><br><span class="line">        course.setCname(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//xml中配置</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.factorybean.MyBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>IOC 操作 Bean 管理（bean 作用域）</strong></p><p>在 Spring 里面，默认情况下，bean 是单实例对象，下面进行作用域设置：验证是否为单实例对象，可以创建两个对象，比较它们的地址是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">     <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;emp&quot;</span>, Emp.class);</span><br><span class="line">     Emp emp1=context.getBean(<span class="string">&quot;emp&quot;</span>,Emp.class);</span><br><span class="line">     System.out.println(emp.hashCode());</span><br><span class="line">     System.out.println(emp1.hashCode());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例</p><p>（2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象</p></blockquote></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="comment">&lt;!--设置为多实例--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）singleton 和 prototype 区别</p><p> a）singleton 单实例，prototype 多实例</p><p> b）设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 ；设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象</p><p><strong>IOC 操作 Bean 管理（bean 生命周期）</strong></p><pre><code>1、生命周期 ：从对象创建到对象销毁的过程2、bean 生命周期 （1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）调用 bean 的初始化的方法（需要进行配置初始化的方法） （4）bean 可以使用了（对象获取到了） （5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）3、演示 bean 生命周期 ：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line">         <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;第一步 执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.oname = oname;</span><br><span class="line">         System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;emp&quot;</span>, Emp.class);</span><br><span class="line">         System.out.println(<span class="string">&quot;第四步 获取创建bean的实例对象&quot;</span>);</span><br><span class="line">        System.out.println(emp.hashCode());</span><br><span class="line">      context.close();</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//创建执行的销毁的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件的bean参数配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.Orders&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><span class="comment">&lt;!--配置初始化方法和销毁方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--这里就是通过set方式（注入属性）赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置后置处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;<span class="comment">//创建后置处理器实现类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4、bean 的后置处理器，bean 生命周期有七步 （正常生命周期为五步，而配置后置处理器后为七步）</p><p>（1）通过构造器创建 bean 实例（无参数构造）</p><p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p><p>（3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</p><p>（4）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p><p>（5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</p><p>（6）bean 可以使用了（对象获取到了）</p><p>（7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p></blockquote><p><strong>IOC操作Bean管理（xml自动装配）</strong></p><ul><li><strong>什么是自动装配</strong></li></ul><p>（1）根据指定装配规则（属性名称或者属性类型），spring自动将匹配的属性注入</p><ul><li><strong>演示自动装配过程</strong></li></ul><p>（1）根据属性名称自动注入</p><blockquote><p>bean标签属性autoawire，配置自动装配</p><p>autowire属性常用的两个值：</p><p>​                                            byName根据属性名称注入，注入值bean的id值和类属性名称一样</p><p>​                                            byType：根据属性类型注入</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.autowried.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.autowried.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>\</p><p><strong>IOC 操作 Bean 管理(外部属性文件)</strong></p><ul><li><strong>直接配置数据库信息</strong></li></ul><p>1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    直接配置连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybaties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hu824407&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>引入外部属性文件配置数据库连接池</strong></li></ul><blockquote><p>（1）创建外部属性文件，properties 格式文件，写数据库信息（<strong>jdbc.properties</strong>）</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybaties</span></span><br><span class="line"><span class="attr">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">hu824407</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><span class="comment">&lt;!--引入context名称空间--&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!--引入外部属性文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2基于注解方式"><a href="#2-2基于注解方式" class="headerlink" title="2.2基于注解方式"></a>2.2基于注解方式</h4><p><strong>什么是注解</strong></p><p>（1）注解是代码特殊标记。格式；@注解名称（属性名称&#x3D;属性值，属性名称&#x3D;属性值）</p><p>（2）注解：作用在方法、属性、类上面</p><p>（3）目的：简化xml配置</p><p><strong>Spring针对Bean管理中创建对象提供注解</strong></p><p>（1）@Component</p><p>（2）@Service</p><p>（3）@Controller</p><p>（4）@Repository</p><p>*上面四个注解功能是一样的，都可以用来创建bean实例</p><p><strong>基于注解对对象创建</strong></p><ul><li>第一步，引入依赖</li><li>第二步，开启组件扫描</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.che&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第三步，创建类，在类上面添加创建对象注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解里面属性值可以忽略不写</span></span><br><span class="line"><span class="comment">//默认值是类名称把首字母小写</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span><span class="comment">//等价&lt;bean id=&quot;userService class=&quot;com....&quot;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*开启组件扫描的细节特点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    示例1 use-default-filters=&quot;false&quot;表示现在不使用默认的filter，自己配置filter</span></span><br><span class="line"><span class="comment">        context:include-filter:设置扫描哪些内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.che&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    示例2</span></span><br><span class="line"><span class="comment">        context:exclude-filter 设置不去扫描哪些内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.che&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>基于注解方式实现属性注入</strong></p><p>(1)  @AutoWired   根据属性类型进行自动装配</p><p>第一步：把service和dao创建，在service和dao类上添加创建对象注解</p><p>第二部：service注入dao属性，在service类添加dao类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(value = &quot;userService&quot;)</span><span class="comment">//等价&lt;bean id=&quot;userService class=&quot;com....&quot;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//定义dao类型属性，不需要添加set方法</span></span><br><span class="line">    <span class="comment">//添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add...&quot;</span>);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)  @Qualifier        根据属性名称进行注入</p><p>和上面的@Autowired一起使用(因为UserDao这个借口可能不止UserDaoImpl这一个实现类。所以需要用这个指定)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义dao类型属性，不需要添加set方法</span></span><br><span class="line">   <span class="comment">//添加注入属性注解</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(value = &quot;userDaoImpl&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;add...&quot;</span>);</span><br><span class="line">       userDao.add();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>(3)  @Resource        可以根据类型注入，也可以根据名称注入</p><ul><li>根据属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><ul><li>根据名称</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><p>(4)  @Value    注入普通类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(value = &quot;userService&quot;)</span><span class="comment">//等价&lt;bean id=&quot;userService class=&quot;com....&quot;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;che&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//定义dao类型属性，不需要添加set方法</span></span><br><span class="line">    <span class="comment">//添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;userDaoImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add...&quot;</span>+name);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>完全注解开发</strong></p><p>(1)创建配置类,代替配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//作为配置类代替bean.xml等配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.che&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//加载配置类</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    System.out.println(userService);</span><br><span class="line">    userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h1><h2 id="一、AOP-概念"><a href="#一、AOP-概念" class="headerlink" title="一、AOP(概念)"></a>一、AOP(概念)</h2><h3 id="1什么是AOP"><a href="#1什么是AOP" class="headerlink" title="1什么是AOP"></a>1什么是AOP</h3><p>(1)面前切面编程（方便），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率</p><p>(2)不通过修改源代码方式，在主干功能里添加新功能</p><h3 id="2AOP底层原理"><a href="#2AOP底层原理" class="headerlink" title="2AOP底层原理"></a>2AOP底层原理</h3><h4 id="2-1AOP底层使用动态代理"><a href="#2-1AOP底层使用动态代理" class="headerlink" title="2.1AOP底层使用动态代理"></a>2.1AOP底层使用动态代理</h4><p>（1）有两种情况动态代理</p><p>第一种  有接口情况，使用JDK动态代理</p><ul><li>创建接口实现类代理对象，增强类的方法</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/spring/JDK.jpg" alt="sd"></p><p>第二种 没有接口情况，使用CGLIB动态代理</p><ul><li>创建子类的代理对象，增强类的方法</li></ul><p><img src="https://blog-chy-lua.oss-cn-shanghai.aliyuncs.com/spring/CGLIB.png" alt="sd"></p><h4 id="2-2AOP-JDK动态代理"><a href="#2-2AOP-JDK动态代理" class="headerlink" title="2.2AOP(JDK动态代理)"></a>2.2AOP(JDK动态代理)</h4><p>1.使用JDK动态代理，使用Proxy类里方法创建代理对象</p><p>java.lang.reflect.Proxy</p><ul><li>调用newProxyInstance方法</li></ul><p>方法有三个参数：</p><p> 第一参数，类加载器</p><p> 第二参数，增强方法所在的类，这个类实现的接口，<em>支持多个接口</em></p><p> 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p><p>2编写JDK动态代理代码</p><p>(1)创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2)创建接口实现类，实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)使用Proxy类创建接口代理对象</p><p>(3)使用Proxy类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">        Class[]interfaces=&#123;UserDao.class&#125;;</span><br><span class="line">        UserDaoImpl userDao=<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span>(UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+add);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//创建谁的代理对象，把谁传过来</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增强逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//方法之前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之前。。。&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数。。。&quot;</span>+ Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法执行之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后。。。&quot;</span>+obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">方法执行之前。。。add :传递的参数。。。[1, 2]</span><br><span class="line">方法执行后。。。com.che.spring5.UserDaoImpl@79fc0f2f</span><br><span class="line">result:3</span><br></pre></td></tr></table></figure><h3 id="3AOP术语"><a href="#3AOP术语" class="headerlink" title="3AOP术语"></a>3AOP术语</h3><ul><li><p>1连接点</p></li><li><pre><code class="java">class User&#123;  add()                  1连接点：类里哪些方法可以被增强，这些方法称为连接点  update()                2切入点：实际被真正增强的方法，称为切入点。。这四个方法都可以被增强。但实际增强的叫切入点       select()                     delete()&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 2切入点</span><br><span class="line"></span><br><span class="line">- 3通知（增强）</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  (1)实际增强的部分称为通知</span><br><span class="line">  通知（增强）有多种类型</span><br><span class="line">  - 1前置通知</span><br><span class="line">  - 2后置通知</span><br><span class="line">  - 3环绕通知</span><br><span class="line">  - 4异常通知</span><br><span class="line">  - 5最终通知</span><br></pre></td></tr></table></figure></code></pre></li><li><p>4切面：是动作</p></li><li><p>（1）把通知（增强）应用到切入点的过程</p></li></ul><h3 id="4AOP操作（准备）"><a href="#4AOP操作（准备）" class="headerlink" title="4AOP操作（准备）"></a>4AOP操作（准备）</h3><ol><li><p>Spring框架一般都是基于AspectJ实现AOP操作</p><p>（1）什么是AspectJ？</p><p>​         AspectJ不是Spring组成部分，独立的AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作</p></li><li><p>基于AspectJ实现AOP操作</p></li></ol><p>​        （1）基于xml配置文件实现</p><p>​         （2）基于注解方式实现（常用）</p><ol start="3"><li>在项目工程中引入AOP相关依赖</li></ol><p>4切入点表达式</p><ul><li>切入点表达式作用：知道对哪个类里面哪个方法进行增强</li><li>语法结构</li></ul><p>excution(【权限修饰符】【返回类型】【类全路径】【方法名称】（【参数列表】）)</p><p>举例一：对com.atqia.dao.BookDao类里面的add方法进行增强</p><p>execution（* com.atqia.dao.BookDao.add(..)）</p><p>举例二对com.atqia.dao.BookDao类里面的所有方法进行增强</p><p>execution（* com.atqia.dao.BookDao.*(..)）</p><p>举例三对com.atqia.dao包里所有类里面的所有方法进行增强</p><p>execution（* com.atqia.dao.*.*(..)）</p><h3 id="5AOP操作（AspectJ注解）"><a href="#5AOP操作（AspectJ注解）" class="headerlink" title="5AOP操作（AspectJ注解）"></a>5AOP操作（AspectJ注解）</h3><ul><li><ol><li><p>创建类，在类里面定义方法（被增强类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.spring5.aopanno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建增强类（编写增强逻辑）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.spring5.aopanno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">   <span class="comment">//前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行通知到配置</p><p>（1）在spring配置文件中，开启注解扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.che.spring5.aopanno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)使用注解创建User和UserProxy对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.spring5.aopanno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在增强类上面添加注解@Aspect</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.spring5.aopanno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)在spring配置文件中开启生成代理对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    开启Aspect生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置不同类型的通知</p><p>（1）在增强类里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.che.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@After(value = &quot;execution(* com.che.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;<span class="comment">//有么有异常都输出.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.che.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;<span class="comment">//有异常不输出.结果后输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;afterreturning.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.che.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterthrowing.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.che.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span><span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之前。。。。。&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之后。。。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAop</span><span class="params">()</span>&#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">  环绕之前。。。。。</span><br><span class="line">before.....</span><br><span class="line">add....</span><br><span class="line">afterreturning.....</span><br><span class="line">after......</span><br><span class="line">环绕之后。。。。。。</span><br></pre></td></tr></table></figure><p>手动给个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;add....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试得出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">环绕之前。。。。。</span><br><span class="line">before.....</span><br><span class="line">afterthrowing.....</span><br><span class="line">after......</span><br><span class="line"></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><ol start="5"><li>公共切入点的抽取。</li></ol></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同切入点的抽取</span></span><br><span class="line">   <span class="meta">@Pointcut(value = &quot;execution(* com.che.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointDemo</span><span class="params">()</span>&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//前置通知</span></span><br><span class="line">   <span class="comment">//Before注解表示作为前置通知</span></span><br><span class="line">   <span class="meta">@Before(value = &quot;pointDemo()&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>6有多个增强类对同一个方法进行增强，设置增强类的优先级</p><p>（1）在增强类上添加@Order（数值）,数值越小优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUser</span> &#123;</span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.che.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;proxy的before增强方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxy的before增强方法</span><br><span class="line">环绕之前。。。。。</span><br><span class="line">before.....</span><br><span class="line">add....</span><br><span class="line">afterreturning.....</span><br><span class="line">after......</span><br><span class="line">环绕之后。。。。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li><p>完全使用注解开发</p><p>（1）创建配置类不需要创建xml文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.che.spring5.Aopconf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.che&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopXml</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAop</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AopXml.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6AOP操作（AspectJ配置文件）-了解"><a href="#6AOP操作（AspectJ配置文件）-了解" class="headerlink" title="6AOP操作（AspectJ配置文件）(了解)"></a>6AOP操作（AspectJ配置文件）(了解)</h3>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
